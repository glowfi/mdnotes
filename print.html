<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Markdown Notes</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1_react_1_fundamentals.html"><strong aria-hidden="true">1.</strong> 1_react_1_fundamentals</a></li><li class="chapter-item expanded "><a href="2_react_2_advanced.html"><strong aria-hidden="true">2.</strong> 2_react_2_advanced</a></li><li class="chapter-item expanded "><a href="3_react_3_axios.html"><strong aria-hidden="true">3.</strong> 3_react_3_axios</a></li><li class="chapter-item expanded "><a href="4_react_4_router_dom.html"><strong aria-hidden="true">4.</strong> 4_react_4_router_dom</a></li><li class="chapter-item expanded "><a href="5_react_5_redux_tookit.html"><strong aria-hidden="true">5.</strong> 5_react_5_redux_tookit</a></li><li class="chapter-item expanded "><a href="6_node_1_fundamentals.html"><strong aria-hidden="true">6.</strong> 6_node_1_fundamentals</a></li><li class="chapter-item expanded "><a href="7_node_2_advanced.html"><strong aria-hidden="true">7.</strong> 7_node_2_advanced</a></li><li class="chapter-item expanded "><a href="8_node_3_orm.html"><strong aria-hidden="true">8.</strong> 8_node_3_orm</a></li><li class="chapter-item expanded "><a href="9_node_4_apollo_graphql_basics.html"><strong aria-hidden="true">9.</strong> 9_node_4_apollo_graphql_basics</a></li><li class="chapter-item expanded "><a href="10_node_5_typescript.html"><strong aria-hidden="true">10.</strong> 10_node_5_typescript</a></li><li class="chapter-item expanded "><a href="11_node_6_graphql_ts_orm.html"><strong aria-hidden="true">11.</strong> 11_node_6_graphql_ts_orm</a></li><li class="chapter-item expanded "><a href="12_sql.html"><strong aria-hidden="true">12.</strong> 12_sql</a></li><li class="chapter-item expanded "><a href="13_sql_alchemy.html"><strong aria-hidden="true">13.</strong> 13_sql_alchemy</a></li><li class="chapter-item expanded "><a href="14_redis.html"><strong aria-hidden="true">14.</strong> 14_redis</a></li><li class="chapter-item expanded "><a href="15_fastapi.html"><strong aria-hidden="true">15.</strong> 15_fastapi</a></li><li class="chapter-item expanded "><a href="16_react_hooks_compressed.html"><strong aria-hidden="true">16.</strong> 16_react_hooks_compressed</a></li><li class="chapter-item expanded "><a href="17_react_Typescript.html"><strong aria-hidden="true">17.</strong> 17_react_Typescript</a></li><li class="chapter-item expanded "><a href="18_next_JS_14.html"><strong aria-hidden="true">18.</strong> 18_next_JS_14</a></li><li class="chapter-item expanded "><a href="19_React+Node_JS_JWT.html"><strong aria-hidden="true">19.</strong> 19_React+Node_JS_JWT</a></li><li class="chapter-item expanded "><a href="20_Golang.html"><strong aria-hidden="true">20.</strong> 20_Golang</a></li><li class="chapter-item expanded "><a href="21_Fastapi_JWT_Scratch_React.html"><strong aria-hidden="true">21.</strong> 21_Fastapi_JWT_Scratch_React</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Markdown Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="react-i"><a class="header" href="#react-i">React I</a></h1>
<blockquote>
<p>What is React and some of its advantages.</p>
</blockquote>
<ul>
<li>
<p>React is a <strong>Javascript library for creating user interfaces</strong>.</p>
</li>
<li>
<p>React is all about <strong>components</strong>. Components are <strong>idependent chunks
of user interfaces</strong> ,which can be pieced up together like lego
blocks and as a result we will be able to create a complex app.</p>
</li>
<li>
<p>Components are <strong>independent , isolated &amp; resuable</strong> and once they are ready they can
be used anywhere. So if we want to change a logic in one of the components
we have do it only in one place and all the instances where we are
using it will be updated with the new logic.</p>
</li>
<li>
<p>Basically we can <strong>update the logic of components without
breaking our whole app</strong> ,if we are making an app which is divided
into multiple isolated components.</p>
</li>
<li>
<p>Under the hood React is very <strong>fast</strong> as it uses something called
<strong>Virtual DOM</strong> which only updates the components which requires
updating and without re-rendering our whole app.</p>
</li>
</ul>
<h3 id="npx"><a class="header" href="#npx">NPX</a></h3>
<p>NPX will only execute the package and will not install the package
globally</p>
<h3 id="popluar-options-to-get-setup-reactjs"><a class="header" href="#popluar-options-to-get-setup-reactjs">Popluar options to get setup ReactJS</a></h3>
<ul>
<li>Vite (Pronounced as Veet) [https://create-react-app.dev/docs/getting-started]</li>
<li>create-react-app [https://vitejs.dev/]</li>
</ul>
<p><b>Snippet to setup react with create-react-app</b></p>
<p>Will craete a folder a named myapp</p>
<pre><code class="language-sh">npx create-react-app myapp
cd myapp
npm audit fix --force
</code></pre>
<h3 id="what-is-webpack"><a class="header" href="#what-is-webpack">What is webpack?</a></h3>
<p>Webpack is a tool that helps developers bundle and manage their JavaScript code.
It takes all the different files (assets,scripts,iamges) and dependencies in a project and combines them into a single file,
making it easier to load and run in a web browser. It also optimizes the code by removing
any unnecessary parts.</p>
<h3 id="what-is-babel"><a class="header" href="#what-is-babel">What is Babel?</a></h3>
<p>Babel is a JavaScript compiler
Babel is a tool that helps developers write modern
JavaScript code and convert it into a version that can
be understood by older browsers.</p>
<h3 id="babel-vs-webpack"><a class="header" href="#babel-vs-webpack">Babel vs Webpack</a></h3>
<p>Babel helps with making modern JavaScript code compatible with older browsers,
while webpack is a tool for bundling and managing JavaScript code
for web development</p>
<h3 id="folder-structure"><a class="header" href="#folder-structure">Folder Structure</a></h3>
<ul>
<li>
<p><strong>node_modules</strong> : Contains all dependencies required by our app.</p>
</li>
<li>
<p><strong>public</strong> : Contains static assests including index.html</p>
<pre><code> index.html
    - title
    - fonts
    - css
    - favicon
    - id="root" - our entire app
</code></pre>
</li>
<li>
<p><strong>src</strong> : Contains all our javascript files . We do all our work here.
Brain of our app.src/index.js is the JavaScript entry point.</p>
</li>
<li>
<p><strong>package.json</strong> : Contains info about our projects like name,version,scripts,
dependencies</p>
</li>
<li>
<p><strong>package.json.lock</strong> : Contains a snapshot of our dependency tree. Automatically
generated when installing or updating packages in a JavaScript project.
It keeps track of the exact versions of all the dependencies
installed in the project.</p>
</li>
</ul>
<hr />
<h2 id="react-fundamentals"><a class="header" href="#react-fundamentals">React Fundamentals</a></h2>
<p><strong>export vs export default</strong></p>
<div class="table-wrapper"><table><thead><tr><th>export (named export)</th><th>export default</th></tr></thead><tbody>
<tr><td>Can have muliple export in a single file</td><td>Can have only single</td></tr>
<tr><td>Imported module should have the same name as the exported module</td><td>Imported module can have any name</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Boiler Plate</p>
</blockquote>
<ul>
<li>Delete the src created and recreate the folder</li>
<li>Inside src create index.js (entrypoint of our react app)</li>
</ul>
<p><strong>Rules for writing components</strong></p>
<ul>
<li>Always start name with capital letter</li>
<li>Must return JSX element.</li>
<li>Must self close the component wherever you use it you use it. <br>
Example : &lt;/Hello&gt;</li>
</ul>
<p><strong>What is JSX</strong></p>
<p>JSX stands for JavaScript XML.
JSX is a syntax extension for JavaScript that allows you to
write HTML-like code in your JavaScript files. It's used
in popular frameworks like React and Vue.js.
JSX code is transpiled into regular JavaScript
code before being executed by the browser.</p>
<p><strong>Rules for JSX</strong></p>
<ul>
<li>
<p><strong>Must return one single parent element</strong>. Either enclose the JSX
return entire with inbuilt html tags or react Fragments.
React Fragments helps us to let's us to group elements without
adding extra node</p>
<pre><code class="language-js">// One way
return &lt;React.Fragment&gt;...rest of the return&lt;/React.Fragment&gt;;

// Another way
return &lt;&gt;...rest of the return&lt;/&gt;;
</code></pre>
</li>
<li>
<p><strong>camelCase for defininig property names</strong></p>
</li>
</ul>
<pre><code class="language-js">return (
  &lt;div tabIndex={1}&gt;
    &lt;button onClick={myFunction}&gt;click me&lt;/button&gt;
    &lt;label htmlFor='name'&gt;Name&lt;/label&gt;
    &lt;input readOnly={true} id='name' /&gt;
  &lt;/div&gt;
)
// in html
&lt;div tabindex="1"&gt;
    &lt;button onclick="myFunction()"&gt;click me&lt;/button&gt;
    &lt;label for='name'&gt;Name&lt;/label&gt;
    &lt;input readonly id='name' /&gt;
&lt;/div&gt;
</code></pre>
<ul>
<li><strong>Close every element</strong></li>
</ul>
<p>Close every tag that does not even supports closing in HTML5</p>
<pre><code class="language-js">return &lt;img /&gt;;
// or
return &lt;input /&gt;;
</code></pre>
<ul>
<li><strong>Formatting</strong></li>
</ul>
<p>Use () to enclose return statements when returning some
nested elements.We can ignore () when returning just 1
single element.</p>
<pre><code class="language-js">function Hello() {
    return (
        &lt;&gt;
            &lt;div className="someValue"&gt;
                &lt;h3&gt;hello world&lt;/h3&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;a href="#"&gt;hello world&lt;/a&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
            &lt;h2&gt;hello world&lt;/h2&gt;
            &lt;input type="text" name="" id="" /&gt;
        &lt;/&gt;
    );
}
</code></pre>
<p><strong>Basic React APP</strong></p>
<blockquote>
<p>index.js</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import ReactDOM from 'react-dom/client';

const Hello = () =&gt; {
    return &lt;h1&gt;Hello World&lt;/h1&gt;;
};

const root = ReactDOM.createRoot(document.getElementById('root'));

root.render(&lt;Hello /&gt;);
</code></pre>
<p><strong>Create element in react</strong></p>
<blockquote>
<p>Using JSX is easier to read than using react's createElement</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import ReactDOM from 'react-dom/client';

// With JSX
const Hello = () =&gt; {
    return &lt;h1&gt;Hello&lt;/h1&gt;;
};

// With React craete element
const Hello = () =&gt; {
    return React.createElement('h1', {}, 'Hello');
};

// Nested React createElement
const Hello = () =&gt; {
    return React.createElement(
        'div',
        {},
        React.createElement('h1', {}, 'Hello')
    );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;Hello /&gt;);
</code></pre>
<hr />
<h3 id="simple-booklist-app"><a class="header" href="#simple-booklist-app">Simple Booklist App</a></h3>
<ul>
<li><strong>1. First Steps</strong></li>
</ul>
<pre><code class="language-js">import React from 'react';
import ReactDOM from 'react-dom/client';

// Booklist
const Booklist = () =&gt; {
    return (
        &lt;&gt;
            &lt;Book /&gt;
            &lt;Book /&gt;
            &lt;Book /&gt;
        &lt;/&gt;
    );
};

// Book
const Book = () =&gt; {
    return (
        &lt;&gt;
            &lt;Image /&gt;
            &lt;Title /&gt;
            &lt;Author /&gt;
        &lt;/&gt;
    );
};

// Items in Book
const Image = () =&gt; {
    return (
        &lt;img
            src="https://m.media-amazon.com/images/I/51TrWpIwMfL.jpg"
            alt="IMG"
        /&gt;
    );
};

const Title = () =&gt; {
    return &lt;h3&gt;David Copperfield&lt;/h3&gt;;
};

const Author = () =&gt; {
    return &lt;p&gt;Charles Dickens&lt;/p&gt;;
};

// Render
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;Booklist /&gt;);
</code></pre>
<ul>
<li><strong>2. Adding CSS</strong></li>
</ul>
<p>Create an index.css in src</p>
<blockquote>
<p>index.css</p>
</blockquote>
<pre><code class="language-css">/* Reset CSS */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family:
        system-ui,
        -apple-system,
        BlinkMacSystemFont,
        'Segoe UI',
        Roboto,
        Oxygen,
        Ubuntu,
        Cantarell,
        'Open Sans',
        'Helvetica Neue',
        sans-serif;
    background: #f1f5f8;
    color: #222;
}

/* CSS */

.booklist {
    width: 90vw;
    max-width: 1170px;
    margin: 3rem 3rem;
    display: grid;
    gap: 2rem;
}

.book {
    background: #fff;
    border-radius: 1rem;
    padding: 2rem;
    text-align: center;
}
.book img {
    width: 100%;
    object-fit: cover;
}
.book h3 {
    margin-top: 1rem;
    font-size: 1rem;
}

/* Media Query */

@media screen and (min-width: 768px) {
    .booklist {
        grid-template-columns: repeat(3, 1fr);
    }
}
</code></pre>
<blockquote>
<p>index.js</p>
</blockquote>
<p>Import the css by mentioning the path at the top of js file</p>
<pre><code class="language-js">import './index.css';
</code></pre>
<h3 id="local-images"><a class="header" href="#local-images">Local Images</a></h3>
<ul>
<li>
<p>local images (public folder) - less performant</p>
</li>
<li>
<p>local images (src folder) - better solution for assets, since under the hood they get optimized.</p>
</li>
</ul>
<p>Note :<b> Whenever using public folder images and writing an URL,
Imagine that u are in public folder and write the image path as
below.I Know its not logical why ./ is used but assume you are
in public folder.You can type in the browser the url
http://localhost:3000/images/&lt;imgname.ext&gt; and see the image will
appear that you have placed in the public/image folder.</b></p>
<pre><code class="language-js">const Image = () =&gt; (
    &lt;img
        src="./images/book-1.jpg"
        alt="Interesting Facts For Curious Minds"
        alt="IMG"
    /&gt;
);
</code></pre>
<h3 id="jsx-css"><a class="header" href="#jsx-css">JSX CSS</a></h3>
<ul>
<li>{} in JSX means going back to JS Land</li>
<li>value is an object with key/value pairs - capitalized and with ''</li>
<li>property names should be in camel case</li>
</ul>
<blockquote>
<p>Example (Inline CSS)</p>
</blockquote>
<pre><code class="language-js">const Author = () =&gt; (
    &lt;h4 style={{ color: '#617d98', fontSize: '0.75rem', marginTop: '0.5rem' }}&gt;
        Jordan Moore
    &lt;/h4&gt;
);
</code></pre>
<blockquote>
<p>Alternative option using variables</p>
</blockquote>
<pre><code class="language-js">const Author = () =&gt; {
    const inlineHeadingStyles = {
        color: '#617d98',
        fontSize: '0.75rem',
        marginTop: '0.5rem'
    };
    return &lt;h4 style={inlineHeadingStyles}&gt;Jordan Moore &lt;/h4&gt;;
};
</code></pre>
<h3 id="jsx-js"><a class="header" href="#jsx-js">JSX JS</a></h3>
<ul>
<li>{} in JSX means going back to JS Land</li>
<li>value inside must be an expression (return value), can't be a statement</li>
</ul>
<pre><code class="language-js">import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';

// Booklist
const Booklist = () =&gt; {
    return (
        &lt;section className="booklist"&gt;
            &lt;Book /&gt;
            &lt;Book /&gt;
            &lt;Book /&gt;
        &lt;/section&gt;
    );
};

// Book
const author = 'Charles Dickens'; // variable can be outside
const Book = () =&gt; {
    const title = 'David Copperfield'; // variable can be inside
    return (
        &lt;article className="book"&gt;
            &lt;img
                src="https://m.media-amazon.com/images/I/51TrWpIwMfL.jpg"
                alt="IMG"
            /&gt;
            &lt;h3&gt;{title}&lt;/h3&gt;
            &lt;p&gt;{author.toUpperCase()}&lt;/p&gt;
            {/* &lt;p&gt;{let x = 6}&lt;/p&gt; */}
            &lt;p&gt;${6 + 6}&lt;/p&gt;
        &lt;/article&gt;
    );
};

// Render
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;Booklist /&gt;);
</code></pre>
<h3 id="props-basics"><a class="header" href="#props-basics">Props Basics</a></h3>
<ul>
<li>Props, short for properties, are a way to pass data from one component to another in React.</li>
<li>Props can be named anything like xyz</li>
</ul>
<pre><code class="language-js">import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';

const author = 'Charles Dickens';
const title = 'David Copperfield';
const img = 'https://m.media-amazon.com/images/I/51TrWpIwMfL.jpg';

// Booklist
const Booklist = () =&gt; {
    return (
        &lt;section className="booklist"&gt;
            &lt;Book img={img} title={title} author={author} /&gt;
            &lt;Book img={img} title={title} author={author} /&gt;
        &lt;/section&gt;
    );
};

// Book [Destructuring inside body]

const Book = (props) =&gt; {
    const { img, title, author } = props;
    return (
        &lt;article className="book"&gt;
            &lt;img src={img} alt={title} /&gt;
            &lt;h3&gt;{title}&lt;/h3&gt;
            &lt;p&gt;{author.toUpperCase()}&lt;/p&gt;
        &lt;/article&gt;
    );
};

// Book [Destructuring in the parameter itself]
const Book = ({ img, title, author }) =&gt; {
    return (
        &lt;article className="book"&gt;
            &lt;img src={img} alt={title} /&gt;
            &lt;h3&gt;{title}&lt;/h3&gt;
            &lt;p&gt;{author.toUpperCase()}&lt;/p&gt;
        &lt;/article&gt;
    );
};

// Render
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;Booklist /&gt;);
</code></pre>
<h3 id="children-props"><a class="header" href="#children-props">Children props</a></h3>
<ul>
<li>everything we render between component tags</li>
<li>mostly use it in Context API</li>
<li>special prop, has to be named "children"</li>
<li>can place anywhere in JSX</li>
</ul>
<pre><code class="language-js">import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';

const author = 'Charles Dickens';
const title = 'David Copperfield';
const img = 'https://m.media-amazon.com/images/I/51TrWpIwMfL.jpg';

// Booklist
const Booklist = () =&gt; {
    return (
        &lt;section className="booklist"&gt;
            &lt;Book img={img} title={title} author={author}&gt;
                &lt;p&gt;
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit.
                    Eligendi, repellat.
                &lt;/p&gt;
                &lt;button type="button"&gt;click me&lt;/button&gt;
            &lt;/Book&gt;
            &lt;Book img={img} title={title} author={author} /&gt;
        &lt;/section&gt;
    );
};

// Book
const Book = ({ img, title, author, children }) =&gt; {
    return (
        &lt;article className="book"&gt;
            &lt;img src={img} alt={title} /&gt;
            &lt;h3&gt;{title}&lt;/h3&gt;
            &lt;p&gt;{author.toUpperCase()}&lt;/p&gt;
            {children}
        &lt;/article&gt;
    );
};

// Render
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;Booklist /&gt;);
</code></pre>
<h3 id="simple-list"><a class="header" href="#simple-list">Simple List</a></h3>
<p>Note : <strong>map - creates a new array from calling a function for every array element.</strong> <br/></p>
<p>Note: <strong>Use Keyprop to assign unique value.The key prop in React is used to uniquely identify
each element in a list of elements that have the same type. This is necessary because React
needs a way to keep track of which elements have changed so that it can efficiently update the UI.</strong></p>
<pre><code class="language-js">import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';

const data = [
    {
        author: 'Charles Dickens',
        title: 'David Copperfield',
        img: 'https://m.media-amazon.com/images/I/51TrWpIwMfL.jpg',
        id: 1
    },
    {
        author: 'Charles Dickens',
        title: 'Oliver Twist',
        img: 'https://m.media-amazon.com/images/I/81QGqaKWjXL._AC_UF1000,1000_QL80_.jpg',
        id: 2
    }
];

// const obj = {
//     author: 'Charles Dickens',
//     title: 'Oliver Twist',
//     img: 'https://m.media-amazon.com/images/I/81QGqaKWjXL._AC_UF1000,1000_QL80_.jpg'
// };

const Booklist = () =&gt; {
    return (
        &lt;&gt;
            &lt;section className="booklist"&gt;
                {data.map(({ author, title, img }, index) =&gt; {
                    return (
                        &lt;Book
                            author={author}
                            title={title}
                            img={img}
                            key={index}
                        /&gt;
                    );
                })}
            &lt;/section&gt;
        &lt;/&gt;
    );
};

const Book = (props) =&gt; {
    const { author, title, img } = props;
    return (
        &lt;article className="book"&gt;
            &lt;img src={img} alt={title} /&gt;
            &lt;h3&gt;{title}&lt;/h3&gt;
            &lt;p&gt;{author}&lt;/p&gt;
        &lt;/article&gt;
    );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;Booklist /&gt;);
</code></pre>
<h3 id="spread-operator"><a class="header" href="#spread-operator">Spread Operator</a></h3>
<pre><code class="language-js">import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';

const data = [
    {
        author: 'Charles Dickens',
        title: 'David Copperfield',
        img: 'https://m.media-amazon.com/images/I/51TrWpIwMfL.jpg',
        id: 1
    },
    {
        author: 'Charles Dickens',
        title: 'Oliver Twist',
        img: 'https://m.media-amazon.com/images/I/81QGqaKWjXL._AC_UF1000,1000_QL80_.jpg',
        id: 2
    }
];

const Booklist = () =&gt; {
    return (
        &lt;&gt;
            &lt;section className="booklist"&gt;
                {data.map((book, index) =&gt; {
                    return &lt;Book {...book} key={index} /&gt;;
                })}
            &lt;/section&gt;
        &lt;/&gt;
    );
};

const Book = (props) =&gt; {
    const { author, title, img } = props;
    return (
        &lt;article className="book"&gt;
            &lt;img src={img} alt={title} /&gt;
            &lt;h3&gt;{title}&lt;/h3&gt;
            &lt;p&gt;{author}&lt;/p&gt;
        &lt;/article&gt;
    );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;Booklist /&gt;);
</code></pre>
<h3 id="event-basics"><a class="header" href="#event-basics">Event Basics</a></h3>
<pre><code class="language-js">import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';

const Booklist = () =&gt; {
    return (
        &lt;&gt;
            &lt;section className="booklist"&gt;
                &lt;EventBasics /&gt;
            &lt;/section&gt;
        &lt;/&gt;
    );
};

// e can be any name , e signifies event , every event handler function (like onClick,onSubmit) has access to event object
const handleSubmit = (e) =&gt; {
    e.preventDefault();
    console.log('submit');
    console.log(e);
};

const handleClick = (e) =&gt; {
    console.log('click');
};
const handleChange = (e) =&gt; {
    console.log('change');
    console.log(e);
    console.log(e.target.value);
    console.log(e.target.name);
};

// Arrow Functions too have access to event object
const EventBasics = () =&gt; {
    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;input type="text" name="txt" onChange={handleChange} /&gt;
            &lt;br /&gt;
            &lt;button
                type="button"
                onClick={(e) =&gt; {
                    console.log(e);
                }}
            &gt;
                Submit
            &lt;/button&gt;
        &lt;/form&gt;
    );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;Booklist /&gt;);
</code></pre>
<h3 id="prop-drilling"><a class="header" href="#prop-drilling">Prop Drilling</a></h3>
<ul>
<li>react data flow - can only pass props down from parent component to child</li>
<li>alternatives Context API, redux, other state libraries</li>
</ul>
<h3 id="drilling-by-passing-a-function-down"><a class="header" href="#drilling-by-passing-a-function-down">Drilling by passing a function down</a></h3>
<pre><code class="language-js">import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';

const data = [
    {
        author: 'Charles Dickens',
        title: 'David Copperfield',
        img: 'https://m.media-amazon.com/images/I/51TrWpIwMfL.jpg',
        id: 1
    },
    {
        author: 'Charles Dickens',
        title: 'Oliver Twist',
        img: 'https://m.media-amazon.com/images/I/81QGqaKWjXL._AC_UF1000,1000_QL80_.jpg',
        id: 2
    }
];

const Booklist = () =&gt; {
    const getBook = (id) =&gt; {
        const k = data.filter((item) =&gt; item.id == id);
        return k;
    };
    return (
        &lt;&gt;
            &lt;section className="booklist"&gt;
                {data.map((book, index) =&gt; {
                    return (
                        &lt;Book
                            newitem="sd"
                            {...book}
                            key={index}
                            getBook={getBook}
                        /&gt;
                    );
                })}
            &lt;/section&gt;
        &lt;/&gt;
    );
};

const Book = (props) =&gt; {
    // console.log(props);
    const { author, title, img, id, getBook } = props;
    return (
        &lt;article className="book"&gt;
            &lt;img src={img} alt={title} /&gt;
            &lt;h3&gt;{title}&lt;/h3&gt;
            &lt;p&gt;{author}&lt;/p&gt;
            &lt;button
                type="button"
                onClick={() =&gt; {
                    console.log(getBook(id));
                }}
            &gt;
                click
            &lt;/button&gt;
        &lt;/article&gt;
    );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;Booklist /&gt;);
</code></pre>
<h3 id="local-images-src"><a class="header" href="#local-images-src">Local Images (src)</a></h3>
<ul>
<li>better performance because optimized</li>
</ul>
<pre><code class="language-js">import img1 from './images/book-1.jpg';
import img2 from './images/book-2.jpg';
import img3 from './images/book-3.jpg';
</code></pre>
<h3 id="vite-setup"><a class="header" href="#vite-setup">Vite Setup</a></h3>
<ul>
<li>need to use .jsx extension</li>
<li>index.html in the source instead of public</li>
<li>assets still in public</li>
<li>instead of index.js, need to use main.jsx</li>
<li>to spin up dev server - "npm run dev"</li>
<li>rest the same - imports/exports, deployment, assets, etc...</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-ii"><a class="header" href="#react-ii">React II</a></h1>
<p><strong>Note : When a state value changes in a React component, the component will
re-render to reflect the new changes. This includes both unmounting
and mounting the component.</strong></p>
<h3 id="react-hooks"><a class="header" href="#react-hooks">React Hooks</a></h3>
<h4 id="usestate"><a class="header" href="#usestate">useState</a></h4>
<p>It returns an array with 2 elements first element is the current
state value and second element is the function to update the state.</p>
<p>State is used to store and manage data that can change over time,
such as user input, API responses, or the current state of a component.</p>
<p>Note : <strong>We need to use state to trigger re-render ,otherwise
suppose we are doing the samething using pure js we had to
come up with our own logic to trigger re-render.</strong></p>
<blockquote>
<p>Triggering re-render manually using vanilla js</p>
</blockquote>
<pre><code class="language-js">const App = () =&gt; {
    let count = 0;

    const handleClick = () =&gt; {
        count += 1;
        console.log(count);
        let k = document.getElementById('changeme');
        k.innerHTML = `${count}`;
    };
    return (
        &lt;&gt;
            &lt;h1 id="changeme"&gt;{count}&lt;/h1&gt;
            &lt;button type="button" onClick={handleClick}&gt;
                click
            &lt;/button&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<blockquote>
<p>Basic useState example using counter</p>
</blockquote>
<pre><code class="language-js">import { useState } from 'react';

const App = () =&gt; {
    const [count, setCount] = useState(0);
    const handleClick = () =&gt; {
        // We trigger re-render on updates and value is preserved
        setCount((c) =&gt; c + 1); // Can pass any values and any name
    };

    return (
        &lt;&gt;
            &lt;h1&gt;{count}&lt;/h1&gt;
            &lt;button type="button" onClick={handleClick}&gt;
                click
            &lt;/button&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<p><strong>Intial render and re-render</strong></p>
<ul>
<li>
<p>In a React application, the initial render is the first
time that the component tree is rendered to the DOM. It
happens when the application first loads, or when the root
component is first rendered. This is also known as
"mounting" the components.</p>
</li>
<li>
<p>Re-renders, on the other hand, happen when the component's
state or props change, and the component needs to be
updated in the DOM to reflect these changes. React uses a
virtual DOM to optimize the process of updating the actual
DOM, so that only the necessary changes are made.</p>
</li>
</ul>
<p>There are a few ways that you can trigger a re-render in a
React component:</p>
<ul>
<li>
<p>By changing the component's state or props. When the
component's state or props change, React will re-render
the component to reflect these changes.</p>
</li>
<li>
<p>When the parent element re-renders, even if the
component's state or props have not changed.</p>
</li>
</ul>
<p><strong>Hooks rules</strong></p>
<ul>
<li><strong>starts with "use" (both custom and react inbuilt hooks)</strong></li>
<li><strong>must be invoked inside a component</strong></li>
<li><strong>dont call hooks conditionally</strong></li>
<li><strong>set function do not update immediately. Do not expect synchronous behaviour.</strong>
<strong>use the count function above log the value in handleClick function to verify.</strong></li>
</ul>
<blockquote>
<p>Basic array clearAll and clearOne example with useState</p>
</blockquote>
<pre><code class="language-js">import { useState } from 'react';

const App = () =&gt; {
    const data = [
        { name: 'abc', id: 1 },
        { name: 'def', id: 2 },
        { name: 'hello', id: 3 }
    ];
    const [people, setPeople] = useState(data);

    const clearAll = () =&gt; {
        setPeople([]);
    };
    const clearOne = (id) =&gt; {
        const newData = people.filter((p) =&gt; {
            return p.id != id;
        });

        setPeople(newData);
    };

    return (
        &lt;&gt;
            {people.map(({ name, id }, idx) =&gt; {
                return (
                    &lt;div key={id}&gt;
                        &lt;h1&gt;{name}&lt;/h1&gt;
                        &lt;button
                            type="button"
                            onClick={() =&gt; {
                                clearOne(id);
                            }}
                        &gt;
                            Delete
                        &lt;/button&gt;
                    &lt;/div&gt;
                );
            })}
            &lt;br /&gt;
            &lt;button type="button" onClick={clearAll}&gt;
                Delete all
            &lt;/button&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<h4 id="automatic-batching"><a class="header" href="#automatic-batching">Automatic Batching</a></h4>
<p>In React, "batching" refers to the process of grouping
multiple state updates into a single update. This can be
useful in certain cases because it allows React to
optimize the rendering of your components by minimizing
the number of DOM updates that it has to perform.</p>
<p>By default, React uses a technique called "auto-batching"
to group state updates that occur within the same event
loop into a single update. This means that if you call the
state update function multiple times in a short period of
time, React will only perform a single re-render for all
of the updates.</p>
<p>React v18 ensures that state updates invoked from any
location will be batched by default. This will batch state
updates, including native event handlers, asynchronous
operations, timeouts, and intervals.</p>
<h4 id="cyclic-behaviour-with-objects"><a class="header" href="#cyclic-behaviour-with-objects">Cyclic behaviour with objects</a></h4>
<pre><code class="language-js">import { useState } from 'react';

const App = () =&gt; {
    const data = [
        { name: 'abc', id: 1 },
        { name: 'def', id: 2 },
        { name: 'hello', id: 3 }
    ];
    const [idx, setIdx] = useState(0);
    const [people, setPeople] = useState(data[idx]);

    const length = data.length;

    return (
        &lt;div&gt;
            &lt;h1&gt;{people.name}&lt;/h1&gt;
            &lt;button
                type="button"
                onClick={() =&gt; {
                    let newIdx = (idx + 1) % length;
                    setIdx(newIdx);
                    setPeople(data[newIdx]);
                }}
            &gt;
                Show {data[(idx + 1) % length].name}
            &lt;/button&gt;
        &lt;/div&gt;
    );
};

export default App;
</code></pre>
<h4 id="getting-old-values"><a class="header" href="#getting-old-values">Getting old values</a></h4>
<ul>
<li>By default react will grab old values and increase it by 1 in
the setTimeout function. Because in the 3 seconds timespan the
setvalue function is still referencing the old value i.e. 0
so to fix it we use a callback.We typically use this callback
if we have some functionality which dependes on latest value.
To simulate that synchronous beahviour we do as it is below.
To preserve the value we use the callback , the value does not
gets preserved if no callback is used.</li>
</ul>
<ul>
<li>The reason why in your code the log function logs an outdated value is
because of closure - the count value is a const, and it is set when
the component is first rendered. So when you click the button, the value
of count is not the new value, but the one it was when it was
first rendered (i.e. -&gt; always going to be one less than you expect).</li>
</ul>
<p><strong>[When inside function it will have the same value as it had in its first render]</strong><br/>
<strong>Refer closures</strong>
<a href="https://github.com/facebook/react/issues/14010">Issue</a></p>
<ul>
<li>In this code, log happens on every re-render. Since clicking the button
calls setCount, the state changes, and a re-render occurs. When that
happens, the log is executed, and you get the latest value</li>
</ul>
<p><strong>React hooks do not update value immediately</strong></p>
<p>React hooks do not update values immediately because of the way they are designed
to work. When a state value is updated using hooks, React schedules a
re-render of the component. During this re-render, the updated value
is applied to the component and any subsequent code that
relies on the updated value is executed.
If you need to perform some action immediately after a state update,
you can use the useEffect hook to run side effects after the
component has rendered with the updated values.</p>
<blockquote>
<p>fixed</p>
</blockquote>
<pre><code class="language-js">import { useState, useEffect } from 'react';

const App = () =&gt; {
    const [count, setCount] = useState(0);
    const handleCLick = () =&gt; {
        setCount((oldval) =&gt; oldval + 1); // this will work and get the latest value
        console.log(count); // will not work still
    };
    console.log(count); // will work
    return (
        &lt;&gt;
            &lt;div&gt;
                &lt;h1&gt;{count}&lt;/h1&gt;
                &lt;button type="button" onClick={handleCLick}&gt;
                    click
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<blockquote>
<p>Example with setTimeout</p>
</blockquote>
<pre><code class="language-js">import { useState } from 'react';

const App = () =&gt; {
    const [count, setCount] = useState(0);

    const handleClick = () =&gt; {
        setTimeout(() =&gt; {
            // will reference old value
            // setCount(count + 1);

            // will reference latest value and preserve value between renders
            // must use return statement
            setCount(oldval =&gt;
                oldval + 1;
            );
        }, 3000);
    };

    return (
        &lt;&gt;
            &lt;h1&gt;{count}&lt;/h1&gt;
            &lt;button type="button" onClick={handleClick}&gt;
                click
            &lt;/button&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<h4 id="useeffect"><a class="header" href="#useeffect">useEffect</a></h4>
<p>useEffect is a hook in React that allows you to perform side
effects in function components.There is no need for urban
dictionary - basically any work outside of the component. Some</p>
<p>Its a way of telling react what to do on component re-render.
Perform side-effects i.e actions that occur outside the DOM.
examples of side effects are: subscriptions, fetching data,
directly updating the DOM, re-registering and de-registering
event listeners, timers, etc.</p>
<p>Note : <strong>If you a noramal JS function and calling it inside a component
it will re-run after every re-render</strong></p>
<pre><code class="language-js">import { useState, useEffect } from 'react';

const App = () =&gt; {
    const [count, setCount] = useState(0);
    const handleCLick = () =&gt; {
        setCount((oldval) =&gt; oldval + 1);
        console.log(count);
    };

    const hello = () =&gt; {
        console.log('hello');
        //setCount(count + 1); // cause inifinite re-reender
    };

    // will get called after re-renders
    hello();

    return (
        &lt;&gt;
            &lt;div&gt;
                &lt;h1&gt;{count}&lt;/h1&gt;
                &lt;button type="button" onClick={handleCLick}&gt;
                    click
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<ul>
<li>accepts two arguments (second optional)</li>
<li>first argument - callback function</li>
<li>second argument — dependency array</li>
<li><strong>by default runs on each render (initial and re-render)
cb can't return promise (so can't make it async)</strong></li>
<li><strong>dont make the callback of useEffect async ever</strong></li>
<li>if dependency array empty [I runs only on initial render]</li>
</ul>
<blockquote>
<p>Why use it</p>
</blockquote>
<p>useEffect is used in React to perform side effects in functional components. Side effects
are actions that occur outside of the component, such as fetching data from
an API, subscribing to events, or manipulating the DOM.</p>
<p>The useEffect hook allows you to specify a function that will be
executed after every render of the component. This function can perform any
necessary side effects. It can also return a cleanup function that will be
executed before the component is unmounted or before the next render.</p>
<p>By using useEffect, you can ensure that side effects are only performed when
necessary and avoid unnecessary re-renders. It helps to keep the component's
logic organized and separate from the rendering logic.</p>
<blockquote>
<p>Why useEffect runs twice {You will see this behaviour while fetching and logging data from API}?</p>
</blockquote>
<ul>
<li>component appears more than once in a page</li>
<li>somehting higher up the tree is unmounting and remounting</li>
<li>reaact strictmode is on</li>
</ul>
<blockquote>
<p>useEffect fetch data from an API</p>
</blockquote>
<pre><code class="language-js">import { useState, useEffect } from 'react';

const App = () =&gt; {
    const URL = 'https://api.github.com/users';
    const [people, setPeople] = useState([]);

    useEffect(() =&gt; {
        const getData = async () =&gt; {
            const data = await fetch(URL);
            const resp = await data.json();
            return resp;
        };

        getData().then((data) =&gt; {
            console.log(data);
            setPeople(data);
        });
    }, []);

    return (
        &lt;&gt;
            &lt;div&gt;
                {people.map(({ login, avatar_url }, idx) =&gt; {
                    return (
                        &lt;div key={idx}&gt;
                            &lt;img src={avatar_url} alt={login} width={'100px'} /&gt;
                            &lt;h1 key={idx}&gt;{login}&lt;/h1&gt;
                        &lt;/div&gt;
                    );
                })}
            &lt;/div&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<h3 id="multiple-returns"><a class="header" href="#multiple-returns">Multiple returns</a></h3>
<pre><code class="language-js">import { useEffect, useState } from 'react';

const App = () =&gt; {
    const URL = 'https://api.github.com/users/QuincyLarson';
    const [iserror, setisError] = useState(false);
    const [isloading, setisLoading] = useState(true);
    const [people, setPeople] = useState([]);

    // Making Useeffect run on initial render only otherwise it will keep hitting the api on each re-render
    useEffect(() =&gt; {
        const getData = async () =&gt; {
            try {
                const response = await fetch(URL);
                const json = await response.json();
                console.log(response);

                // By default fetch api does not take HTTP code in range of 4xx-5xx as errors
                // Instead it considers status code to be indicative of success
                if (!response.ok) {
                    setisLoading(false);
                    setisError(true);
                    return;
                }
                setPeople(json);
                setisLoading(false);
            } catch (err) {
                setisError(true);
                setisLoading(false);
            }
        };

        getData();
    }, []);

    // If is loading show loading

    if (isloading) {
        return (
            &lt;&gt;
                &lt;h1&gt;Loading ...&lt;/h1&gt;
            &lt;/&gt;
        );
    }

    // If Error show error

    if (iserror) {
        return (
            &lt;&gt;
                &lt;h1&gt;Error&lt;/h1&gt;
            &lt;/&gt;
        );
    }

    // show data

    return (
        &lt;&gt;
            &lt;h1&gt;{JSON.stringify(people, null, 8)}&lt;/h1&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<h3 id="order-matters"><a class="header" href="#order-matters">Order matters</a></h3>
<ul>
<li>
<p>Order matters : We should not destructure any user properties
before getting the results.</p>
</li>
<li>
<p>Use optional chaining to spit back an empty value if not present</p>
</li>
</ul>
<h3 id="location-of-fetch-function"><a class="header" href="#location-of-fetch-function">Location of fetch function</a></h3>
<p>if we are placing the fetch function outside the Useeffect
don not place the fetch function name into the dependency
array because on re-render fetch function will be recreated
and we will encounter an inifinite loop.</p>
<h3 id="toggling-a-component-using-ternary-operator"><a class="header" href="#toggling-a-component-using-ternary-operator">Toggling a component using ternary operator</a></h3>
<pre><code class="language-js">import { useState } from 'react';

const Hello = () =&gt; {
    return &lt;h1&gt;Hello&lt;/h1&gt;;
};

const App = () =&gt; {
    const [isvisible, setIsvisible] = useState(false);
    return (
        &lt;&gt;
            {isvisible ? &lt;Hello /&gt; : ''}
            &lt;button
                type="button"
                onClick={() =&gt; {
                    setIsvisible(!isvisible);
                }}
            &gt;
                click
            &lt;/button&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<h3 id="login-logout-with-ternary"><a class="header" href="#login-logout-with-ternary">login logout with ternary</a></h3>
<pre><code class="language-js">import { useState } from 'react';

const App = () =&gt; {
    const [user, setUser] = useState(null);
    return (
        &lt;&gt;
            {user ? (
                &lt;Loggedin {...user} setUser={setUser} /&gt;
            ) : (
                &lt;Loggedout setUser={setUser} /&gt;
            )}
        &lt;/&gt;
    );
};

const Loggedin = ({ name, setUser }) =&gt; {
    return (
        &lt;&gt;
            &lt;button
                type="button"
                onClick={() =&gt; {
                    setUser(null);
                }}
            &gt;
                Logout
            &lt;/button&gt;
            &lt;h1&gt;Hello {name}&lt;/h1&gt;
        &lt;/&gt;
    );
};

const Loggedout = ({ setUser }) =&gt; {
    return (
        &lt;&gt;
            &lt;button
                type="button"
                onClick={() =&gt; {
                    setUser({ name: 'johndoe' });
                }}
            &gt;
                Login
            &lt;/button&gt;
            &lt;h1&gt;Logged out&lt;/h1&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<h3 id="cleanup-function"><a class="header" href="#cleanup-function">Cleanup Function</a></h3>
<p>In the below code since we are re-rendering the component conditionally
what we are doing is we are mounting and unmounting the component.One
thing to note is that useEffect runs on inital render and on every
re-render.But in the below code we have setup useEffect to run
on inital load but since we are <strong>Toggling the component conditionally
we are repeating the initial render process everytime we specially mount,
as a result useEffect will executed</strong>.</p>
<blockquote>
<p>Example showing useEffect will run on remounting the components as it repeats the initial re-render process</p>
</blockquote>
<pre><code class="language-js">import { useEffect, useState } from 'react';

const Hello = () =&gt; {
    // will run everytime we remount the component as its the initial render
    useEffect(() =&gt; {
        console.log('useefect ran..');
    }, []);
    return &lt;h3&gt;hello&lt;/h3&gt;;
};

const App = () =&gt; {
    const [toggle, setisToggled] = useState(false);
    return (
        &lt;&gt;
            {toggle ? &lt;Hello /&gt; : ''}
            &lt;button
                type="button"
                onClick={() =&gt; {
                    setisToggled(!toggle);
                }}
            &gt;
                toggle
            &lt;/button&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<h3 id="cleanup-function-setinterval-example-to-tun-somehting-on-mount-and-unmount"><a class="header" href="#cleanup-function-setinterval-example-to-tun-somehting-on-mount-and-unmount">Cleanup function setInterval example to tun somehting on mount and unmount</a></h3>
<pre><code class="language-js">import { useEffect, useState } from 'react';

const Hello = () =&gt; {
    // Do not make the useEffect callback async as it expects only a function to reurn in our case its cleanup function
    useEffect(() =&gt; {
        // will run on component mount
        const id = setInterval(() =&gt; {
            console.log('useefect ran..');
        }, 1000);

        // will run on component unmount
        return () =&gt; {
            console.log('cleanup');
            clearInterval(id);
        };
    }, []);
    return &lt;h3&gt;hello&lt;/h3&gt;;
};

const App = () =&gt; {
    const [toggle, setisToggled] = useState(false);
    console.log('render');
    return (
        &lt;&gt;
            {toggle ? &lt;Hello /&gt; : ''}
            &lt;button
                type="button"
                onClick={() =&gt; {
                    setisToggled(!toggle);
                }}
            &gt;
                toggle
            &lt;/button&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<h4 id="folder-structure-and-named-export"><a class="header" href="#folder-structure-and-named-export">Folder structure and named export</a></h4>
<p>When working with react we can use index.js to group export all components needed</p>
<pre><code>   Navbar (Folder)
      - index.css
      - index.js -&gt; [import first from first;import second from second ]and then [export {first,second}]
      - first component
      - second component
</code></pre>
<p>Now from App.jsx we just now import components like<br/>
<code>import {first,second} from ./Navbar</code><br/>
No need to mention any file name as index.js is entrypoint</p>
<h4 id="leverage-everything-known-till-now"><a class="header" href="#leverage-everything-known-till-now">Leverage everything known till now</a></h4>
<blockquote>
<p>List.jsx [Iterates over all People]</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import Person from './Person';

const List = (props) =&gt; {
    const { data } = props;
    return (
        &lt;div&gt;
            {data.map((p, idx) =&gt; {
                return (
                    &lt;div key={idx}&gt;
                        &lt;Person {...p} /&gt;
                    &lt;/div&gt;
                );
            })}
        &lt;/div&gt;
    );
};

export default List;
</code></pre>
<blockquote>
<p>Person.jsx [Component to show only one person and details like name]</p>
</blockquote>
<p>Uses optional chaining</p>
<pre><code class="language-js">import React from 'react';

const Person = (props) =&gt; {
    // const { name, nickName } = props;
    const { level } = props;
    // const lev = level &amp;&amp; level[0] &amp;&amp; level[0].count;
    const lev = level?.[0].count || 0;

    return (
        &lt;div style={{ border: '2px solid black' }}&gt;
            &lt;h1&gt; {props.name}&lt;/h1&gt;
            &lt;p&gt; {props.nickName}&lt;/p&gt;
            &lt;p&gt; {lev}&lt;/p&gt;
        &lt;/div&gt;
    );
};

export default Person;
</code></pre>
<blockquote>
<p>App.jsx [Show the list]</p>
</blockquote>
<pre><code class="language-js">import List from './List';

const data = [
    { id: 1, name: 'bob', nickName: 'Stud Muffin' },
    { id: 2, name: 'peter', nickName: 'Hello World', level: [{ count: 3 }] }
];

const App = () =&gt; {
    return (
        &lt;&gt;
            &lt;List data={data} /&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<h3 id="controlled-input"><a class="header" href="#controlled-input">Controlled Input</a></h3>
<blockquote>
<p>App.jsx [Displays the form and previous list of people]</p>
</blockquote>
<pre><code class="language-js">import { useState } from 'react';
import List from './List';

const data = [
    { id: 1, name: 'bob', nickName: 'Stud Muffin' },
    { id: 2, name: 'peter', nickName: 'Hello World', level: [{ count: 3 }] }
];

const ControlledInput = ({ setPeople, people }) =&gt; {
    const [name, setName] = useState('');
    const [nickName, setNickname] = useState('');
    return (
        &lt;&gt;
            &lt;form&gt;
                &lt;div&gt;
                    &lt;p&gt;Name&lt;/p&gt;
                    &lt;input
                        type="text"
                        name=""
                        value={name}
                        onChange={(e) =&gt; {
                            setName(e.target.value);
                        }}
                    /&gt;
                &lt;/div&gt;
                &lt;div&gt;
                    &lt;p&gt;nickName&lt;/p&gt;
                    &lt;input
                        type="text"
                        name=""
                        value={nickName}
                        onChange={(e) =&gt; {
                            setNickname(e.target.value);
                        }}
                    /&gt;
                &lt;/div&gt;
                &lt;button
                    type="button"
                    onClick={() =&gt; {
                        console.log(name);
                        console.log(nickName);
                        setPeople((people) =&gt; {
                            return [
                                ...people,
                                {
                                    name: name,
                                    nickName: nickName,
                                    id: new Date()
                                }
                            ];
                        });
                    }}
                &gt;
                    SUbmit
                &lt;/button&gt;
            &lt;/form&gt;
        &lt;/&gt;
    );
};

const App = () =&gt; {
    const [people, setPeople] = useState(data);
    return (
        &lt;&gt;
            &lt;ControlledInput setPeople={setPeople} people={people} /&gt;
            &lt;List data={people} setPeople={setPeople} people={people} /&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<blockquote>
<p>List.jsx [Iterates over all people]</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import Person from './Person';

const List = (props) =&gt; {
    const { data, setPeople, people } = props;
    return (
        &lt;div&gt;
            {data.map((p, idx) =&gt; {
                return (
                    &lt;div key={idx}&gt;
                        &lt;Person {...p} setPeople={setPeople} people={people} /&gt;
                    &lt;/div&gt;
                );
            })}
        &lt;/div&gt;
    );
};

export default List;
</code></pre>
<blockquote>
<p>People.jsx [Remove functionality on click based on id]</p>
</blockquote>
<pre><code class="language-js">import React from 'react';

const Person = (props) =&gt; {
    // const { name, nickName } = props;
    const { level, setPeople, people, id } = props;
    // const lev = level &amp;&amp; level[0] &amp;&amp; level[0].count;
    const lev = level?.[0].count || 0;

    const handleRemove = () =&gt; {
        // const newData = people.filter((p) =&gt; p.id != id);
        const newData = people.filter((p) =&gt; {
            if (id != p.id) {
                return p;
            }
        });
        setPeople(newData);
    };

    return (
        &lt;div style={{ border: '2px solid black' }}&gt;
            &lt;h1&gt; {props.name}&lt;/h1&gt;
            &lt;p&gt; {props.nickName}&lt;/p&gt;
            &lt;p&gt; {lev}&lt;/p&gt;
            &lt;button type="button" onClick={handleRemove}&gt;
                Remove
            &lt;/button&gt;
        &lt;/div&gt;
    );
};

export default Person;
</code></pre>
<h3 id="multiple-inputs"><a class="header" href="#multiple-inputs">Multiple inputs</a></h3>
<p>For multiple inputs use square bracket notation to use the Javascript's
inbuilt dynamic object key feature.</p>
<h3 id="checkbox"><a class="header" href="#checkbox">Checkbox</a></h3>
<p>To access checkbox make checked = the state value and
onChange make the e.target.checked = current state value</p>
<h3 id="select-statement-example"><a class="header" href="#select-statement-example">Select statement example</a></h3>
<pre><code class="language-js">&lt;select
    value={val}
    onChange={(e) =&gt; {
        console.log(e.target.value);
    }}
&gt;
    &lt;option&gt;1&lt;/option&gt;
    &lt;option&gt;2&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<h3 id="form-data-api"><a class="header" href="#form-data-api">Form Data API</a></h3>
<blockquote>
<p>Difference b/w e.target &amp; e.currentTarget</p>
</blockquote>
<ul>
<li><strong>e.target</strong> refers to the element that triggered the event,<br/></li>
<li><strong>e.currentTarget</strong> refers to the element that the event listener is attached to.</li>
</ul>
<pre><code class="language-js">const handleSubmit = (e) =&gt; {
    e.preventDefault();

    const formData = new FormData(e.currentTarget);

    // get values one by one
    const name = formData.get('name');
    console.log(name);

    // get all of them
    const newUser = Object.fromEntries(formData);

    // do something (post request, add to list, etc)
    console.log(newUser);

    // Gotcha - re-render won't clear out the values
    setValue(value + 1);
    // reset values
    e.currentTarget.reset();
};
</code></pre>
<h4 id="useref"><a class="header" href="#useref">useRef</a></h4>
<p>useRef is a hook in React that allows you to create a
reference to a DOM element or a value that persists
across re-renders.</p>
<p>It returns a mutable ref object which contains the reference
to a particular element or value in a react component . We
can use this to modify or read the value.</p>
<p>It can be used to access and modify the properties of
a DOM element, store a value that needs to be
accessed by multiple components, or to store
a value that needs to persist between renders
without triggering a re-render.</p>
<ul>
<li>useRef does not trigger re-render</li>
<li>initial value is an object with its key as current. {current:value you have set}</li>
</ul>
<blockquote>
<p>Plain use ref example with an input</p>
</blockquote>
<pre><code class="language-js">import { useRef } from 'react';

const App = () =&gt; {
    // It is initaited in form of an object {current:null} in this case
    const refCont = useRef(null);

    const handleChange = () =&gt; {
        // It is nothing but the input element as refCont is assocaited with ref
        console.log(refCont);
    };

    return (
        &lt;div&gt;
            &lt;input
                type="text"
                name="name"
                ref={refCont}
                onChange={handleChange}
            /&gt;
        &lt;/div&gt;
    );
};

export default App;
</code></pre>
<blockquote>
<p>Making useEffect not run on initial render but on value change</p>
</blockquote>
<pre><code class="language-js">import React, { useEffect, useRef, useState } from 'react';

const App = () =&gt; {
    const [val, setVal] = useState(0);
    const isMounted = useRef(false);

    useEffect(() =&gt; {
        // ran every re-render and initial render preventing
        // Clenaup -&gt; Re-render
        if (!isMounted.current) {
            isMounted.current = true;
            return;
        }
        console.log('ran useEffect');

        // unomunt test
        return () =&gt; {
            console.log('cleanup');
        };
    });

    return (
        &lt;div&gt;
            &lt;h3&gt;{val}&lt;/h3&gt;
            &lt;button
                type="button"
                onClick={() =&gt; {
                    setVal(val + 1);
                }}
            &gt;
                click
            &lt;/button&gt;
        &lt;/div&gt;
    );
};

export default App;
</code></pre>
<h3 id="custom-hooks"><a class="header" href="#custom-hooks">Custom Hooks</a></h3>
<blockquote>
<p>useFetch.js</p>
</blockquote>
<pre><code class="language-js">import React, { useEffect, useState } from 'react';

const useFetch = (URL) =&gt; {
    const [isloading, setIsloading] = useState(true);
    const [iserror, setIserror] = useState(false);
    const [data, setData] = useState(null);

    useEffect(() =&gt; {
        const getData = async () =&gt; {
            const resp = await fetch(URL);
            if (!resp.ok) {
                setIserror(true);
                setIsloading(false);
            }
            const json = await resp.json();
            setData(json);
            setIsloading(false);
        };
        console.log('start');
        setTimeout(() =&gt; {
            getData();
        }, 3000);
        console.log('end');
    }, []);

    console.log('mid');
    return { iserror, isloading, data };
};

export default useFetch;
</code></pre>
<blockquote>
<p>App.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import useFetch from './useFetch';

const App = () =&gt; {
    const URL = 'https://api.github.com/users/QuincyLarson';

    const { isloading, iserror, data } = useFetch(URL);
    console.log(isloading); //will be called 2 times

    if (isloading) {
        return &lt;h3&gt;Loading ....&lt;/h3&gt;;
    }
    if (iserror) {
        return &lt;h3&gt;Error ....&lt;/h3&gt;;
    }

    return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;
};

export default App;
</code></pre>
<h3 id="context-api"><a class="header" href="#context-api">Context API</a></h3>
<ul>
<li><strong>create a context using createContext</strong></li>
<li><strong>Must wrap the component in Context.Provider</strong></li>
<li><strong>Pass any properties using the <code>value</code> prop</strong></li>
<li><strong>access the created xontext using useContext hook</strong></li>
</ul>
<blockquote>
<p>App.jsx</p>
</blockquote>
<pre><code class="language-js">import React, { createContext, useState } from 'react';
import List from './List';

export const logincontext = createContext();

const App = () =&gt; {
    const [user, setUser] = useState(null);

    const logout = () =&gt; {
        setUser(null);
    };

    const login = (name) =&gt; {
        setUser(name);
    };

    const data = [{ name: 'abc' }, { name: 'def' }, { name: 'ghi' }];

    return (
        &lt;div&gt;
            {user ? (
                &lt;&gt;
                    &lt;h3&gt;Hello {user}&lt;/h3&gt;
                    &lt;button
                        type="button"
                        onClick={() =&gt; {
                            logout();
                        }}
                    &gt;
                        Logout
                    &lt;/button&gt;
                &lt;/&gt;
            ) : (
                &lt;&gt;
                    &lt;h3&gt;Not logged in&lt;/h3&gt;
                &lt;/&gt;
            )}
            &lt;logincontext.Provider value={{ login }}&gt;
                &lt;List data={data} /&gt;
            &lt;/logincontext.Provider&gt;
        &lt;/div&gt;
    );
};

export default App;
</code></pre>
<blockquote>
<p>List.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import Person from './Person';

const List = ({ data }) =&gt; {
    return (
        &lt;&gt;
            {data.map((p, idx) =&gt; {
                return (
                    &lt;div key={idx}&gt;
                        &lt;div&gt;
                            &lt;Person name={p.name} /&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                );
            })}
        &lt;/&gt;
    );
};

export default List;
</code></pre>
<blockquote>
<p>Person.jsx</p>
</blockquote>
<pre><code class="language-js">import React, { useContext } from 'react';
import { logincontext } from './App';

const Person = ({ name }) =&gt; {
    const { login } = useContext(logincontext);

    return (
        &lt;div&gt;
            &lt;h3&gt;{name}&lt;/h3&gt;
            &lt;button
                type="button"
                onClick={() =&gt; {
                    login(name);
                }}
            &gt;
                Login
            &lt;/button&gt;
        &lt;/div&gt;
    );
};

export default Person;
</code></pre>
<h3 id="global-context"><a class="header" href="#global-context">Global Context</a></h3>
<ul>
<li>in src create context.jsx</li>
<li>setup a global context - GlobalContext</li>
<li>setup a component (AppContext) with one state value</li>
<li>return GlobalContext.Provider from AppContext</li>
<li>wrap then entire application (main.jsx) - children prop "gotcha"</li>
<li>setup a custom hook</li>
<li>access in App.jsx</li>
<li>log result</li>
</ul>
<h3 id="reducer"><a class="header" href="#reducer">Reducer</a></h3>
<blockquote>
<p>Structure of inbuilt reducer</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { useReducer } from 'react';

const data = [{ name: 'abc' }, { name: 'def' }, { name: 'ghi' }];

// Initial State
const defState = {
    people: data
};

// Reducer Function [Must return a state]
// Has access to current state,and action
const reducer = (state, action) =&gt; {
    return state;
};

const App = () =&gt; {
    // dispatch({type:"action-name",payload:"abc"})
    // state-&gt;current state
    const [state, dispatch] = useReducer(reducer, defState);

    return &lt;div&gt;App&lt;/div&gt;;
};

export default App;
</code></pre>
<blockquote>
<p>useReducer basics</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { useReducer } from 'react';

const data = [
    { name: 'abc', id: 1 },
    { name: 'def', id: 2 },
    { name: 'ghi', id: 3 }
];

const CLEAR_ALL = 'clear-all';
const REMOVE_ITEM = 'remove-item';
const RESET_LIST = 'reset-list';

// Initial State
const defState = {
    people: data
};

// Reducer Function [Must return a state]
// Has access to current state,and action
const reducer = (state, action) =&gt; {
    // Remove a single Person
    if (action.type === REMOVE_ITEM) {
        const newState = state.people.filter((p) =&gt; p.id != action.payload);
        console.log(newState);
        return { ...state, people: newState };
    }
    // Remove all
    else if (action.type === CLEAR_ALL) {
        return { ...state, people: [] };
    }
    // Reset List
    else if (action.type === RESET_LIST) {
        return { ...state, people: data };
    }
    return state;
};

const App = () =&gt; {
    // dispatch({type:"action",payload:"abc"})
    // state-&gt;current state
    const [state, dispatch] = useReducer(reducer, defState);
    console.log(state);

    return (
        &lt;div&gt;
            {state.people.map(({ name, id }, idx) =&gt; {
                return (
                    &lt;div key={idx}&gt;
                        &lt;h3&gt;{name}&lt;/h3&gt;
                        &lt;button
                            type="button"
                            onClick={() =&gt; {
                                dispatch({ type: REMOVE_ITEM, payload: id });
                            }}
                        &gt;
                            Remove Item
                        &lt;/button&gt;
                    &lt;/div&gt;
                );
            })}
            &lt;br /&gt;
            &lt;div&gt;
                &lt;button
                    type="button"
                    onClick={() =&gt; {
                        dispatch({ type: CLEAR_ALL });
                    }}
                &gt;
                    Clear All
                &lt;/button&gt;
                &lt;br /&gt;
                &lt;button
                    type="button"
                    onClick={() =&gt; {
                        dispatch({ type: RESET_LIST });
                    }}
                &gt;
                    Rest List
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
};

export default App;
</code></pre>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>When Component Re-Renders :</p>
<ul>
<li>
<p>When the component's state or props change, React will re-render the component to reflect these changes.</p>
</li>
<li>
<p>When the parent element re-renders, even if the component's state or props have not changed.</p>
</li>
</ul>
<p>If u take the below example the Counter componet fixes the issue of re-rendering everytime
ofthe Childnest component on parent component state change . Because re-renders the child
component if the parent re-renders.</p>
<blockquote>
<p>Parent.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { useState } from 'react';
import Child from './Child';
import Counter from './Counter';

const data = [
    { name: 'abc', id: 1 },
    { name: 'def', id: 2 },
    { name: 'ghi', id: 3 }
];

// Triggers re-renders of the Childnest component on state change of the count variable

// const Parent = () =&gt; {
// const [count, setCount] = useState(0);
//     return (
//         &lt;div&gt;
//             &lt;h1&gt;Count :{count}&lt;/h1&gt;
//             &lt;button
//                 type="button"
//                 onClick={() =&gt; {
//                     setCount(count + 1);
//                 }}
//             &gt;
//                 Click
//             &lt;/button&gt;
//             &lt;Child data={data} /&gt;
//         &lt;/div&gt;
//     );
// };

// Issue fixed on movinf the state variable to another component

const Parent = () =&gt; {
    return (
        &lt;div&gt;
            &lt;Counter /&gt;
            &lt;Child data={data} /&gt;
        &lt;/div&gt;
    );
};

export default Parent;
</code></pre>
<blockquote>
<p>Child.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import Childnest from './Childnest';

const Child = ({ data }) =&gt; {
    return (
        &lt;div&gt;
            {data.map(({ name }, idx) =&gt; {
                return (
                    &lt;div key={idx}&gt;
                        &lt;Childnest name={name} /&gt;
                    &lt;/div&gt;
                );
            })}
        &lt;/div&gt;
    );
};

export default Child;
</code></pre>
<blockquote>
<p>Childnest.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';

const Childnest = ({ name }) =&gt; {
    console.log('render');
    return &lt;div&gt;{name}&lt;/div&gt;;
};

export default Childnest;
</code></pre>
<blockquote>
<p>Counter.jsx</p>
</blockquote>
<pre><code class="language-js">import React, { useState } from 'react';

const Counter = () =&gt; {
    const [count, setCount] = useState(0);
    return (
        &lt;&gt;
            &lt;h1&gt;Count :{count}&lt;/h1&gt;
            &lt;button
                type="button"
                onClick={() =&gt; {
                    setCount(count + 1);
                }}
            &gt;
                Click
            &lt;/button&gt;
        &lt;/&gt;
    );
};

export default Counter;
</code></pre>
<p><strong>Note : [Naive way of Fixing] Fixing the re-render by moving the state that causes
re-render of the parent component to another file</strong></p>
<blockquote>
<p>Input.jsx</p>
</blockquote>
<pre><code class="language-js">import React, { useState } from 'react';

const Input = () =&gt; {
    const [name, setName] = useState('');
    return (
        &lt;form&gt;
            &lt;input
                type="text"
                name="name"
                value={name}
                onChange={(e) =&gt; {
                    setName(e.target.value);
                }}
            /&gt;
        &lt;/form&gt;
    );
};

export default Input;
</code></pre>
<blockquote>
<p>App.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { useState } from 'react';
import Child from './Child';
import Input from './Input';

const dataz = [
    { name: 'abc', id: 1 },
    { name: 'def', id: 2 },
    { name: 'ghi', id: 3 }
];

const Parent = () =&gt; {
    const [data, setData] = useState(dataz);

    const addPerson = () =&gt; {
        setData([...data, { name, id: Date.now() }]);
    };

    // Issue fixed
    return (
        &lt;div&gt;
            &lt;Input /&gt;

            &lt;button
                type="button"
                onClick={() =&gt; {
                    addPerson();
                }}
            &gt;
                Add
            &lt;/button&gt;

            &lt;Child data={data} /&gt;
        &lt;/div&gt;
    );
};

export default Parent;
</code></pre>
<h3 id="reactmemo"><a class="header" href="#reactmemo">React.memo</a></h3>
<p>React.memo is a higher-order component (HOC) in React that allows you to memoize a component.
This means that if the input props to the component have not changed, the memoized
component will return the same result from the previous render, instead of re-rendering.
This can help improve performance by avoiding unnecessary render cycles.</p>
<p>The React.memo function takes a functional component as its argument and
returns a new component that has the same behavior, but with the added optimization
of checking if the props have changed. If the props have not changed, the
memoized component will return the cached result from the previous render.</p>
<blockquote>
<p>Child.jsx</p>
</blockquote>
<p>Instead moving the creating separate component to another file.
Use React.memo to trigger re-render only on props changed</p>
<pre><code class="language-js">export default memo(Child);
</code></pre>
<h3 id="usecallback"><a class="header" href="#usecallback">UseCallback</a></h3>
<p>The useCallback hook is a hook in React that allows you to memoize a function. It takes two arguments: the first is the function you want to memoize, and the second is an array of dependencies. The hook will return a memoized version of the function that only changes if one of the values in the dependency array changes.</p>
<p>By memoizing the function, you can avoid unnecessary re-renders and improve the performance of your React application. The function will only be re-created if one of its dependencies changes, otherwise the same instance of the function will be returned. This can be useful in situations where you have an expensive function that you only want to recompute when its dependencies change.</p>
<p>We will notice a gotcha by creating a removePerson function on
App.jsx , we will see even after with React.memo child component
re-renders again.This is happens beacuse when parent component
re-renders on state change in our case when we type input value
the removePerson is created from scratch so as a result when
removePerson is passed down as a prop to another child component
it trigger re-renders as the prop changed</p>
<blockquote>
<p>Wihout Fix</p>
</blockquote>
<pre><code class="language-js">const removePerson = (id) =&gt; {
    const newPeople = people.filter((person) =&gt; person.id !== id);
    setPeople(newPeople);
};
</code></pre>
<blockquote>
<p>Fix</p>
</blockquote>
<pre><code class="language-js">useCallback(
    (id) =&gt; {
        const newPeople = people.filter((person) =&gt; person.id !== id);
        setPeople(newPeople);
    },
    [people]
);
</code></pre>
<blockquote>
<p>useCallback - Common Use Case</p>
</blockquote>
<p>What happens if we keep dependency array as FetchData in
the useEffect is we will encounter inifinite re-renders
as the fetchData is created from scratch.To fix this and
still use fetchData as dependency we can use useCallback
to create the function only on initial re-render.Another fix
is to not use useCallback and remove fetchData from dependency.</p>
<pre><code class="language-js">import { useState, useEffect, useCallback } from 'react';
const url = 'https://api.github.com/users';

const FetchData = () =&gt; {
    const [users, setUsers] = useState([]);
    const fetchData = useCallback(async () =&gt; {
        try {
            const response = await fetch(url);
            const users = await response.json();
            setUsers(users);
        } catch (error) {
            console.log(error);
        }
    }, []);

    useEffect(() =&gt; {
        fetchData();
    }, [fetchData]);
    // rest of the logic
};
</code></pre>
<h3 id="usememo"><a class="header" href="#usememo">useMemo</a></h3>
<p>The useMemo hook is a hook in React that allows you to memoize a value. It
takes two arguments: the first is a function that returns the value you want to
memoize, and the second is an array of dependencies. The hook will return the
memoized value that will only change if one of the values in the dependency array changes.</p>
<p>By memoizing a value, you can avoid unnecessary calculations and improve the performance
of your React application. The value will only be recalculated if one of its dependencies
changes, otherwise the same instance of the value will be returned. This can be useful
in situations where you have an expensive calculation that you only want to recompute
when its dependencies change.</p>
<p>Make the below function run only on first render</p>
<pre><code class="language-js">const slowFunction = () =&gt; {
    let value = 0;
    for (let i = 0; i &lt;= 1000000000; i++) {
        value += i;
    }
    return value;
};

export default slowFunction;

const processedData = useMemo(() =&gt; {
    slowFunction();
}, []);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="axios"><a class="header" href="#axios">Axios</a></h3>
<h4 id="docs"><a class="header" href="#docs">Docs</a></h4>
<p><a href="https://axios-http.com/docs/intro">Axios Docs</a></p>
<h4 id="install"><a class="header" href="#install">Install</a></h4>
<pre><code class="language-sh">npm install axios
</code></pre>
<pre><code class="language-js">&lt;script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"&gt;&lt;/script&gt;
</code></pre>
<h4 id="first-request"><a class="header" href="#first-request">First Request</a></h4>
<ul>
<li>
<p>import axios</p>
</li>
<li>
<p>axios.get(url)</p>
</li>
<li>
<p>axios.post(url)</p>
</li>
<li>
<p>axios.patch/put(url)</p>
</li>
<li>
<p>axios.delete(url)</p>
</li>
<li>
<p>default get axios(url)</p>
</li>
<li>
<p>returns a promise</p>
</li>
<li>
<p>response data located in data property</p>
</li>
<li>
<p>error in error.response</p>
</li>
</ul>
<pre><code class="language-js">import axios from 'axios';

const fetchData = async () =&gt; {
    try {
        // axios.get(), axios.post(),axios.put(), axios.delete()
        const response = await axios(url);

        console.log(response);
    } catch (error) {
        console.log(error.response);
    }
};
</code></pre>
<h4 id="headers"><a class="header" href="#headers">Headers</a></h4>
<ul>
<li>
<p>second argument</p>
</li>
<li>
<p>axios.get(url,{})</p>
</li>
<li>
<p>third argument in requests with data</p>
</li>
<li>
<p>axios.post(url,{data},{})</p>
</li>
</ul>
<pre><code class="language-js">const fetchDadJoke = async () =&gt; {
    try {
        const { data } = await axios(url, {
            headers: {
                Accept: 'application/json'
            }
        });
        // console.log(data);
        setJoke(data.joke);
    } catch (error) {
        console.log(error.response);
    }
};
</code></pre>
<h4 id="post-request"><a class="header" href="#post-request">Post Request</a></h4>
<ul>
<li>send data to the server</li>
<li>axios.post(url, { data })</li>
<li>more options (auth header) - axios.post(url, { data },{})</li>
</ul>
<pre><code class="language-js">try {
    const resp = await axios.post(url, { data });
} catch (error) {
    console.log(error.response.data);
}
</code></pre>
<h4 id="global-defaults"><a class="header" href="#global-defaults">Global Defaults</a></h4>
<pre><code class="language-js">axios.defaults.headers.common['Accept'] = 'application/json';
axios.defaults.baseURL = 'https://api.example.com';
axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;
axios.defaults.headers.post['Content-Type'] =
    'application/x-www-form-urlencoded';
</code></pre>
<h4 id="custom-instance"><a class="header" href="#custom-instance">Custom Instance</a></h4>
<pre><code class="language-js">const authFetch = axios.create({
    baseURL: 'https://course-api.com',
    headers: {
        Accept: 'application/json'
    }
});
</code></pre>
<h4 id="interceptors"><a class="header" href="#interceptors">Interceptors</a></h4>
<ul>
<li>global and custom</li>
</ul>
<pre><code class="language-js">authFetch.interceptors.request.use(
    (request) =&gt; {
        request.headers.common['Accept'] = `application/json`;
        console.log('request sent');
        // must return request
        return request;
    },
    (error) =&gt; {
        return Promise.reject(error);
    }
);

authFetch.interceptors.response.use(
    (response) =&gt; {
        console.log('got response');
        return response;
    },
    (error) =&gt; {
        console.log(error.response);
        if (error.response.status === 404) {
            // do something
            console.log('NOT FOUND');
        }
        return Promise.reject(error);
    }
);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-router"><a class="header" href="#react-router">React Router</a></h1>
<h3 id="install-1"><a class="header" href="#install-1">Install</a></h3>
<pre><code class="language-sh">npm install react-router-dom@6
</code></pre>
<h3 id="basic-setup"><a class="header" href="#basic-setup">Basic Setup</a></h3>
<blockquote>
<p>main.jsx</p>
</blockquote>
<p>Wrap entire app with browser router</p>
<pre><code class="language-js">import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import { BrowserRouter } from 'react-router-dom';

ReactDOM.createRoot(document.getElementById('root')).render(
    &lt;BrowserRouter&gt;
        &lt;App /&gt;
    &lt;/BrowserRouter&gt;
);
</code></pre>
<p>Create 2 simple Pages Home,About</p>
<blockquote>
<p>Home.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';

const Home = () =&gt; {
    return &lt;div&gt;Home&lt;/div&gt;;
};

export default Home;
</code></pre>
<blockquote>
<p>About.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';

const About = () =&gt; {
    return &lt;div&gt;About&lt;/div&gt;;
};

export default About;
</code></pre>
<blockquote>
<p>App.jsx</p>
</blockquote>
<p>We use link because it will not refresh the pages.
If we use anchor tags it will refresh the pages.</p>
<p>Wrap Routes inside Route.
Use Route to define single route.</p>
<pre><code class="language-js">import React from 'react';
import { Link, Route, Routes } from 'react-router-dom';
import Home from './pages/Home';
import About from './pages/About';

const App = () =&gt; {
    return (
        &lt;&gt;
            &lt;nav&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;Link to="/"&gt;Home&lt;/Link&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;Link to="/about"&gt;About&lt;/Link&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/nav&gt;
            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
            &lt;/Routes&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<h3 id="router-types"><a class="header" href="#router-types">Router Types</a></h3>
<ul>
<li>Hashrouter : Routes as #</li>
<li>unstable_HistoryRouter : Give direct acess to history</li>
<li>MemoryRouter: Used for testing.Stores history in memory.</li>
<li>StaticRouter : Does not allow to browse pages.</li>
</ul>
<h3 id="dynamic-routes"><a class="header" href="#dynamic-routes">Dynamic Routes</a></h3>
<p>Create Booklist and Book Component
Goal is read the route paramete like :id.Example: "/abc/xyz/book/:id"</p>
<blockquote>
<p>App.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { Link, Route, Routes } from 'react-router-dom';
import Home from './pages/Home';
import About from './pages/About';
import Books from './pages/Books';
import Book from './pages/Book';

const App = () =&gt; {
    return (
        &lt;&gt;
            &lt;nav&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;Link to="/"&gt;Home&lt;/Link&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;Link to="/about"&gt;About&lt;/Link&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;Link to="/books"&gt;Books&lt;/Link&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/nav&gt;
            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
                &lt;Route path="/books" element={&lt;Books /&gt;} /&gt;
                &lt;Route path="/books/:id" element={&lt;Book /&gt;} /&gt;
            &lt;/Routes&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<blockquote>
<p>Books.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { Link } from 'react-router-dom';

const Books = () =&gt; {
    return (
        &lt;div&gt;
            &lt;h3&gt;Book List&lt;/h3&gt;
            &lt;Link to="/books/1"&gt;book 1&lt;/Link&gt;
            &lt;br /&gt;
            &lt;Link to="/books/2"&gt;book 2&lt;/Link&gt;
            &lt;br /&gt;
            &lt;Link to="/books/3"&gt;book 3&lt;/Link&gt;
            &lt;br /&gt;
        &lt;/div&gt;
    );
};

export default Books;
</code></pre>
<blockquote>
<p>Book.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { useParams } from 'react-router-dom';

const Book = () =&gt; {
    const params = useParams();
    return &lt;div&gt;Book {params.id}&lt;/div&gt;;
};

export default Book;
</code></pre>
<h3 id="route-specificity"><a class="header" href="#route-specificity">Route Specificity</a></h3>
<p>Suppose we have two routes "/books/:id" [1st] "/books/new" [2nd].
In previous version of react router dom what it would had done is gone
with the first match.But newer version will take the hardcoded value as
the possible route option.</p>
<blockquote>
<p>not found</p>
</blockquote>
<pre><code class="language-js">&lt;Route path="*" element={&lt;NotFound /&gt;} /&gt;
</code></pre>
<h3 id="nesting"><a class="header" href="#nesting">Nesting</a></h3>
<blockquote>
<p>App.jsx</p>
</blockquote>
<p>Basic Nesting</p>
<pre><code class="language-js">import React from 'react';
import { Link, Route, Routes } from 'react-router-dom';
import Home from './pages/Home';
import About from './pages/About';
import Books from './pages/Books';
import Book from './pages/Book';
import Notfound from './pages/Notfound';

const App = () =&gt; {
    return (
        &lt;&gt;
            &lt;nav&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;Link to="/"&gt;Home&lt;/Link&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;Link to="/about"&gt;About&lt;/Link&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;Link to="/books"&gt;Books&lt;/Link&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/nav&gt;

            {/* Basic Nesting */}

            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
                &lt;Route path="/books"&gt;
                    &lt;Route index element={&lt;Books /&gt;} /&gt;
                    &lt;Route path=":id" element={&lt;Book /&gt;} /&gt;
                &lt;/Route&gt;

                &lt;Route path="*" element={&lt;Notfound /&gt;} /&gt;
            &lt;/Routes&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<h3 id="basic-nesting-by-passing-a-layout-in-every-children-routes-shared-layout"><a class="header" href="#basic-nesting-by-passing-a-layout-in-every-children-routes-shared-layout">Basic Nesting by passing a layout in every children routes [shared layout]</a></h3>
<blockquote>
<p>Layout.jsx</p>
</blockquote>
<p>Outlet must be added otherwise the dom will painter only with layout's jsx.</p>
<pre><code class="language-js">import React from 'react';
import { Outlet } from 'react-router-dom';

const Layout = () =&gt; {
    return (
        &lt;&gt;
            &lt;h3&gt;This layout is to be shared.&lt;/h3&gt;
            &lt;Outlet /&gt;
        &lt;/&gt;
    );
};

export default Layout;
</code></pre>
<blockquote>
<p>App.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { Link, Route, Routes } from 'react-router-dom';
import Home from './pages/Home';
import About from './pages/About';
import Books from './pages/Books';
import Book from './pages/Book';
import Notfound from './pages/Notfound';
import Layout from './pages/Layout';

const App = () =&gt; {
    return (
        &lt;&gt;
            &lt;nav&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;Link to="/"&gt;Home&lt;/Link&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;Link to="/about"&gt;About&lt;/Link&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;Link to="/books"&gt;Books&lt;/Link&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/nav&gt;

            {/* Basic Nesting */}

            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
                &lt;Route path="/books" element={&lt;Layout /&gt;}&gt;
                    &lt;Route index element={&lt;Books /&gt;} /&gt;
                    &lt;Route path=":id" element={&lt;Book /&gt;} /&gt;
                &lt;/Route&gt;

                &lt;Route path="*" element={&lt;Notfound /&gt;} /&gt;
            &lt;/Routes&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<h3 id="outlet-context"><a class="header" href="#outlet-context">Outlet context</a></h3>
<blockquote>
<p>Layout.jsx</p>
</blockquote>
<p>Outlet can be used to pass context</p>
<pre><code class="language-js">import React from 'react';
import { Outlet } from 'react-router-dom';

const Layout = () =&gt; {
    return (
        &lt;&gt;
            &lt;h3&gt;This layout is to be shared.&lt;/h3&gt;
            &lt;Outlet context={{ hello: 'world', name: 'john' }} /&gt;
        &lt;/&gt;
    );
};

export default Layout;
</code></pre>
<blockquote>
<p>Books.jsx</p>
</blockquote>
<p>Go to any child route adn access the context value with useContext</p>
<pre><code class="language-js">import React from 'react';
import { Link, useOutletContext } from 'react-router-dom';

const Books = () =&gt; {
    const val = useOutletContext();
    console.log(val);
    return (
        &lt;div&gt;
            &lt;h3&gt;Book List&lt;/h3&gt;
            &lt;Link to="/books/1"&gt;book 1&lt;/Link&gt;
            &lt;br /&gt;
            &lt;Link to="/books/2"&gt;book 2&lt;/Link&gt;
            &lt;br /&gt;
            &lt;Link to="/books/3"&gt;book 3&lt;/Link&gt;
            &lt;br /&gt;
        &lt;/div&gt;
    );
};

export default Books;
</code></pre>
<h3 id="routes-in-a-seperate-file"><a class="header" href="#routes-in-a-seperate-file">Routes in a seperate file</a></h3>
<blockquote>
<p>BookRoutes.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { Route, Routes } from 'react-router-dom';
import Books from './pages/Books';
import Book from './pages/Book';
import Layout from './pages/Layout';

const BookRoutes = () =&gt; {
    return (
        &lt;Routes&gt;
            &lt;Route element={&lt;Layout /&gt;}&gt;
                &lt;Route index element={&lt;Books /&gt;} /&gt;
                &lt;Route path=":id" element={&lt;Book /&gt;} /&gt;
            &lt;/Route&gt;
        &lt;/Routes&gt;
    );
};

export default BookRoutes;
</code></pre>
<blockquote>
<p>App.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { Link, Route, Routes } from 'react-router-dom';
import Home from './pages/Home';
import About from './pages/About';
import Notfound from './pages/Notfound';
import BookRoutes from './BookRoutes';

const App = () =&gt; {
    return (
        &lt;&gt;
            &lt;nav&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;Link to="/"&gt;Home&lt;/Link&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;Link to="/about"&gt;About&lt;/Link&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;Link to="/books"&gt;Books&lt;/Link&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/nav&gt;

            {/* Basic Nesting */}

            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
                &lt;Route path="/books/*" element={&lt;BookRoutes /&gt;} /&gt;
                &lt;Route path="*" element={&lt;Notfound /&gt;} /&gt;
            &lt;/Routes&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<h3 id="useroute"><a class="header" href="#useroute">useRoute</a></h3>
<p>We can use Js instead to define routes</p>
<h2 id="handling-navigation"><a class="header" href="#handling-navigation">Handling Navigation</a></h2>
<p>In NavLink , Link ,Navigate</p>
<ul>
<li>replace (replace last visited page with current page),</li>
<li>reloadDocument (referesh the entirepage)</li>
</ul>
<h2 id="navlink"><a class="header" href="#navlink">NavLink</a></h2>
<p>By deafult adds class of active</p>
<pre><code class="language-js">&lt;NavLink
    to="/"
    style={({ isActive }) =&gt; ({ color: isActive ? 'red' : 'black' })}
&gt;
    {({ isActive }) =&gt; {
        return isActive ? 'Active Home' : 'Home';
    }}
&lt;/NavLink&gt;
</code></pre>
<h2 id="navigate"><a class="header" href="#navigate">Navigate</a></h2>
<p>navigate with a component</p>
<pre><code class="language-js">&lt;Navigate to="/" /&gt;
</code></pre>
<h2 id="usenavigate"><a class="header" href="#usenavigate">useNavigate</a></h2>
<p>navigate with a hook</p>
<pre><code class="language-js">const navigate = useNavigate();

unction onSubmit() {
  // Submit form results
  navigate("/books", { replace: true, state: { bookName: "Fake Title" } })
}
</code></pre>
<h2 id="search-params"><a class="header" href="#search-params">Search Params</a></h2>
<p>Access searchparams</p>
<pre><code class="language-js">import React from 'react';
import { Link, useOutletContext, useSearchParams } from 'react-router-dom';

const Books = () =&gt; {
    const val = useOutletContext();

    // Get search parameters
    const [searchparams, setSearchParams] = useSearchParams();
    console.log(searchparams.get('q'));

    // setSearchParams({ n: e.target.value })

    console.log(val);
    return (
        &lt;div&gt;
            &lt;h3&gt;Book List&lt;/h3&gt;
            &lt;Link to="/books/1"&gt;book 1&lt;/Link&gt;
            &lt;br /&gt;
            &lt;Link to="/books/2"&gt;book 2&lt;/Link&gt;
            &lt;br /&gt;
            &lt;Link to="/books/3"&gt;book 3&lt;/Link&gt;
            &lt;br /&gt;
        &lt;/div&gt;
    );
};

export default Books;
</code></pre>
<h2 id="uselocation"><a class="header" href="#uselocation">useLocation</a></h2>
<p>access state data passed from another route</p>
<pre><code class="language-js">const location = useLocation();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="redux-with-redux-toolkit"><a class="header" href="#redux-with-redux-toolkit">Redux with redux-toolkit</a></h3>
<h4 id="docs-1"><a class="header" href="#docs-1">Docs</a></h4>
<p><a href="https://redux-toolkit.js.org/introduction/getting-started">Redux Toolkit Docs</a></p>
<h4 id="install-template"><a class="header" href="#install-template">Install Template</a></h4>
<pre><code class="language-sh">npx create-react-app my-app --template redux
</code></pre>
<ul>
<li>@latest</li>
</ul>
<pre><code class="language-sh">npx create-react-app@latest my-app --template redux
</code></pre>
<h4 id="existing-app"><a class="header" href="#existing-app">Existing App</a></h4>
<pre><code class="language-sh">npm install @reduxjs/toolkit react-redux
</code></pre>
<h4 id="reduxjstoolkit"><a class="header" href="#reduxjstoolkit">@reduxjs/toolkit</a></h4>
<p>consists of few libraries</p>
<ul>
<li>redux (core library, state management)</li>
<li>immer (allows to mutate state)</li>
<li>redux-thunk (handles async actions)</li>
<li>reselect (simplifies reducer functions)</li>
</ul>
<h4 id="extras"><a class="header" href="#extras">Extras</a></h4>
<ul>
<li>redux devtools</li>
<li>combine reducers</li>
</ul>
<h4 id="react-redux"><a class="header" href="#react-redux">react-redux</a></h4>
<p>connects our app to redux</p>
<h4 id="setup-store"><a class="header" href="#setup-store">Setup Store</a></h4>
<ul>
<li>create store.js</li>
</ul>
<pre><code class="language-js">import { configureStore } from '@reduxjs/toolkit';

export const store = configureStore({
    reducer: {}
});
</code></pre>
<h4 id="setup-provider"><a class="header" href="#setup-provider">Setup Provider</a></h4>
<ul>
<li>index.js</li>
</ul>
<pre><code class="language-js">import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
// import store and provider
import { store } from './store';
import { Provider } from 'react-redux';

ReactDOM.render(
    &lt;React.StrictMode&gt;
        &lt;Provider store={store}&gt;
            &lt;App /&gt;
        &lt;/Provider&gt;
    &lt;/React.StrictMode&gt;,
    document.getElementById('root')
);
</code></pre>
<h4 id="setup-cart-slice"><a class="header" href="#setup-cart-slice">Setup Cart Slice</a></h4>
<ul>
<li>application feature</li>
<li>create features folder/cart</li>
<li>create cartSlice.js</li>
</ul>
<pre><code class="language-js">import { createSlice } from '@reduxjs/toolkit';

const initialState = {
    cartItems: [],
    amount: 0,
    total: 0,
    isLoading: true
};

const cartSlice = createSlice({
    name: 'cart',
    initialState
});

console.log(cartSlice);

export default cartSlice.reducer;
</code></pre>
<ul>
<li>store.js</li>
</ul>
<pre><code class="language-js">import { configureStore } from '@reduxjs/toolkit';
import cartReducer from './features/cart/cartSlice';

export const store = configureStore({
    reducer: {
        cart: cartReducer
    }
});
</code></pre>
<h4 id="redux-devtools"><a class="header" href="#redux-devtools">Redux DevTools</a></h4>
<ul>
<li>extension</li>
</ul>
<h4 id="access-store-value"><a class="header" href="#access-store-value">Access store value</a></h4>
<ul>
<li>create components/Navbar.js</li>
</ul>
<pre><code class="language-js">import { CartIcon } from '../icons';
import { useSelector } from 'react-redux';

const Navbar = () =&gt; {
    const { amount } = useSelector((state) =&gt; state.cart);

    return (
        &lt;nav&gt;
            &lt;div className="nav-center"&gt;
                &lt;h3&gt;redux toolkit&lt;/h3&gt;
                &lt;div className="nav-container"&gt;
                    &lt;CartIcon /&gt;
                    &lt;div className="amount-container"&gt;
                        &lt;p className="total-amount"&gt;{amount}&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/nav&gt;
    );
};
export default Navbar;
</code></pre>
<h4 id="hero-icons"><a class="header" href="#hero-icons">Hero Icons</a></h4>
<ul>
<li><a href="https://heroicons.com/">Hero Icons</a></li>
</ul>
<pre><code class="language-css">nav svg {
    width: 40px;
    color: var(--clr-white);
}
</code></pre>
<h4 id="setup-cart"><a class="header" href="#setup-cart">Setup Cart</a></h4>
<ul>
<li>cartSlice.js</li>
</ul>
<pre><code class="language-js">import cartItems from '../../cartItems';

const initialState = {
    cartItems: cartItems,
    amount: 0,
    total: 0,
    isLoading: true
};
</code></pre>
<ul>
<li>create CartContainer.js and CartItem.js</li>
<li>CartContainer.js</li>
</ul>
<pre><code class="language-js">import React from 'react';
import CartItem from './CartItem';
import { useSelector } from 'react-redux';

const CartContainer = () =&gt; {
    const { cartItems, total, amount } = useSelector((state) =&gt; state.cart);

    if (amount &lt; 1) {
        return (
            &lt;section className="cart"&gt;
                {/* cart header */}
                &lt;header&gt;
                    &lt;h2&gt;your bag&lt;/h2&gt;
                    &lt;h4 className="empty-cart"&gt;is currently empty&lt;/h4&gt;
                &lt;/header&gt;
            &lt;/section&gt;
        );
    }
    return (
        &lt;section className="cart"&gt;
            {/* cart header */}
            &lt;header&gt;
                &lt;h2&gt;your bag&lt;/h2&gt;
            &lt;/header&gt;
            {/* cart items */}
            &lt;div&gt;
                {cartItems.map((item) =&gt; {
                    return &lt;CartItem key={item.id} {...item} /&gt;;
                })}
            &lt;/div&gt;
            {/* cart footer */}
            &lt;footer&gt;
                &lt;hr /&gt;
                &lt;div className="cart-total"&gt;
                    &lt;h4&gt;
                        total &lt;span&gt;${total}&lt;/span&gt;
                    &lt;/h4&gt;
                &lt;/div&gt;
                &lt;button className="btn clear-btn"&gt;clear cart&lt;/button&gt;
            &lt;/footer&gt;
        &lt;/section&gt;
    );
};

export default CartContainer;
</code></pre>
<ul>
<li>CartItem.js</li>
</ul>
<pre><code class="language-js">import React from 'react';
import { ChevronDown, ChevronUp } from '../icons';

const CartItem = ({ id, img, title, price, amount }) =&gt; {
    return (
        &lt;article className="cart-item"&gt;
            &lt;img src={img} alt={title} /&gt;
            &lt;div&gt;
                &lt;h4&gt;{title}&lt;/h4&gt;
                &lt;h4 className="item-price"&gt;${price}&lt;/h4&gt;
                {/* remove button */}
                &lt;button className="remove-btn"&gt;remove&lt;/button&gt;
            &lt;/div&gt;
            &lt;div&gt;
                {/* increase amount */}
                &lt;button className="amount-btn"&gt;
                    &lt;ChevronUp /&gt;
                &lt;/button&gt;
                {/* amount */}
                &lt;p className="amount"&gt;{amount}&lt;/p&gt;
                {/* decrease amount */}
                &lt;button className="amount-btn"&gt;
                    &lt;ChevronDown /&gt;
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/article&gt;
    );
};

export default CartItem;
</code></pre>
<h4 id="first-reducer"><a class="header" href="#first-reducer">First Reducer</a></h4>
<ul>
<li>cartSlice.js</li>
<li>Immer library</li>
</ul>
<pre><code class="language-js">const cartSlice = createSlice({
    name: 'cart',
    initialState,
    reducers: {
        clearCart: (state) =&gt; {
            state.cartItems = [];
        }
    }
});

export const { clearCart } = cartSlice.actions;
</code></pre>
<ul>
<li>create action</li>
</ul>
<pre><code class="language-js">const ACTION_TYPE = 'ACTION_TYPE';

const actionCreator = (payload) =&gt; {
    return { type: ACTION_TYPE, payload: payload };
};
</code></pre>
<ul>
<li>CartContainer.js</li>
</ul>
<pre><code class="language-js">import React from 'react';
import CartItem from './CartItem';
import { useDispatch, useSelector } from 'react-redux';

const CartContainer = () =&gt; {
    const dispatch = useDispatch();

    return (
        &lt;button
            className="btn clear-btn"
            onClick={() =&gt; {
                dispatch(clearCart());
            }}
        &gt;
            clear cart
        &lt;/button&gt;
    );
};

export default CartContainer;
</code></pre>
<h4 id="remove-increase-decrease"><a class="header" href="#remove-increase-decrease">Remove, Increase, Decrease</a></h4>
<ul>
<li>cartSlice.js</li>
</ul>
<pre><code class="language-js">import { createSlice } from '@reduxjs/toolkit';
import cartItems from '../../cartItems';

const initialState = {
    cartItems: [],
    amount: 0,
    total: 0,
    isLoading: true
};

const cartSlice = createSlice({
    name: 'cart',
    initialState,
    reducers: {
        clearCart: (state) =&gt; {
            state.cartItems = [];
        },
        removeItem: (state, action) =&gt; {
            const itemId = action.payload;
            state.cartItems = state.cartItems.filter(
                (item) =&gt; item.id !== itemId
            );
        },
        increase: (state, { payload }) =&gt; {
            const cartItem = state.cartItems.find(
                (item) =&gt; item.id === payload.id
            );
            cartItem.amount = cartItem.amount + 1;
        },
        decrease: (state, { payload }) =&gt; {
            const cartItem = state.cartItems.find(
                (item) =&gt; item.id === payload.id
            );
            cartItem.amount = cartItem.amount - 1;
        },
        calculateTotals: (state) =&gt; {
            let amount = 0;
            let total = 0;
            state.cartItems.forEach((item) =&gt; {
                amount += item.amount;
                total += item.amount * item.price;
            });
            state.amount = amount;
            state.total = total;
        }
    }
});

export const { clearCart, removeItem, increase, decrease, calculateTotals } =
    cartSlice.actions;

export default cartSlice.reducer;
</code></pre>
<ul>
<li>CartItem.js</li>
</ul>
<pre><code class="language-js">import React from 'react';
import { ChevronDown, ChevronUp } from '../icons';

import { useDispatch } from 'react-redux';
import { removeItem, increase, decrease } from '../features/cart/cartSlice';

const CartItem = ({ id, img, title, price, amount }) =&gt; {
    const dispatch = useDispatch();

    return (
        &lt;article className="cart-item"&gt;
            &lt;img src={img} alt={title} /&gt;
            &lt;div&gt;
                &lt;h4&gt;{title}&lt;/h4&gt;
                &lt;h4 className="item-price"&gt;${price}&lt;/h4&gt;
                {/* remove button */}
                &lt;button
                    className="remove-btn"
                    onClick={() =&gt; {
                        dispatch(removeItem(id));
                    }}
                &gt;
                    remove
                &lt;/button&gt;
            &lt;/div&gt;
            &lt;div&gt;
                {/* increase amount */}
                &lt;button
                    className="amount-btn"
                    onClick={() =&gt; {
                        dispatch(increase({ id }));
                    }}
                &gt;
                    &lt;ChevronUp /&gt;
                &lt;/button&gt;
                {/* amount */}
                &lt;p className="amount"&gt;{amount}&lt;/p&gt;
                {/* decrease amount */}
                &lt;button
                    className="amount-btn"
                    onClick={() =&gt; {
                        if (amount === 1) {
                            dispatch(removeItem(id));
                            return;
                        }
                        dispatch(decrease({ id }));
                    }}
                &gt;
                    &lt;ChevronDown /&gt;
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/article&gt;
    );
};

export default CartItem;
</code></pre>
<ul>
<li>App.js</li>
</ul>
<pre><code class="language-js">import { useEffect } from 'react';
import Navbar from './components/Navbar';
import CartContainer from './components/CartContainer';
import { useSelector, useDispatch } from 'react-redux';
import { calculateTotals } from './features/cart/cartSlice';

function App() {
    const { cartItems } = useSelector((state) =&gt; state.cart);
    const dispatch = useDispatch();
    useEffect(() =&gt; {
        dispatch(calculateTotals());
    }, [cartItems]);

    return (
        &lt;main&gt;
            &lt;Navbar /&gt;
            &lt;CartContainer /&gt;
        &lt;/main&gt;
    );
}

export default App;
</code></pre>
<h4 id="modal"><a class="header" href="#modal">Modal</a></h4>
<ul>
<li>create components/Modal.js</li>
</ul>
<pre><code class="language-js">const Modal = () =&gt; {
    return (
        &lt;aside className="modal-container"&gt;
            &lt;div className="modal"&gt;
                &lt;h4&gt;Remove all items from your shopping cart?&lt;/h4&gt;
                &lt;div className="btn-container"&gt;
                    &lt;button type="button" className="btn confirm-btn"&gt;
                        confirm
                    &lt;/button&gt;
                    &lt;button type="button" className="btn clear-btn"&gt;
                        cancel
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/aside&gt;
    );
};
export default Modal;
</code></pre>
<ul>
<li>App.js</li>
</ul>
<pre><code class="language-js">return (
    &lt;main&gt;
        &lt;Modal /&gt;
        &lt;Navbar /&gt;
        &lt;CartContainer /&gt;
    &lt;/main&gt;
);
</code></pre>
<h4 id="modal-slice"><a class="header" href="#modal-slice">modal slice</a></h4>
<ul>
<li>create features/modal/modalSlice.js</li>
</ul>
<pre><code class="language-js">import { createSlice } from '@reduxjs/toolkit';
const initialState = {
    isOpen: false
};

const modalSlice = createSlice({
    name: 'modal',
    initialState,
    reducers: {
        openModal: (state, action) =&gt; {
            state.isOpen = true;
        },
        closeModal: (state, action) =&gt; {
            state.isOpen = false;
        }
    }
});

export const { openModal, closeModal } = modalSlice.actions;
export default modalSlice.reducer;
</code></pre>
<ul>
<li>App.js</li>
</ul>
<pre><code class="language-js">const { isOpen } = useSelector((state) =&gt; state.modal);

return (
    &lt;main&gt;
        {isOpen &amp;&amp; &lt;Modal /&gt;}
        &lt;Navbar /&gt;
        &lt;CartContainer /&gt;
    &lt;/main&gt;
);
</code></pre>
<h4 id="toggle-modal"><a class="header" href="#toggle-modal">toggle modal</a></h4>
<ul>
<li>CartContainer.js</li>
</ul>
<pre><code class="language-js">import { openModal } from '../features/modal/modalSlice';

return (
    &lt;button
        className="btn clear-btn"
        onClick={() =&gt; {
            dispatch(openModal());
        }}
    &gt;
        clear cart
    &lt;/button&gt;
);
</code></pre>
<ul>
<li>Modal.js</li>
</ul>
<pre><code class="language-js">import { closeModal } from '../features/modal/modalSlice';
import { useDispatch } from 'react-redux';
import { clearCart } from '../features/cart/cartSlice';

const Modal = () =&gt; {
    const dispatch = useDispatch();

    return (
        &lt;aside className="modal-container"&gt;
            &lt;div className="modal"&gt;
                &lt;h4&gt;Remove all items from your shopping cart?&lt;/h4&gt;
                &lt;div className="btn-container"&gt;
                    &lt;button
                        type="button"
                        className="btn confirm-btn"
                        onClick={() =&gt; {
                            dispatch(clearCart());
                            dispatch(closeModal());
                        }}
                    &gt;
                        confirm
                    &lt;/button&gt;
                    &lt;button
                        type="button"
                        className="btn clear-btn"
                        onClick={() =&gt; {
                            dispatch(closeModal());
                        }}
                    &gt;
                        cancel
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/aside&gt;
    );
};
export default Modal;
</code></pre>
<h4 id="async-functionality-with-createasyncthunk"><a class="header" href="#async-functionality-with-createasyncthunk">async functionality with createAsyncThunk</a></h4>
<ul>
<li>
<p><a href="https://course-api.com/">Course API</a></p>
</li>
<li>
<p>https://course-api.com/react-useReducer-cart-project</p>
</li>
<li>
<p>cartSlice.js</p>
</li>
<li>
<p>action type</p>
</li>
<li>
<p>callback function</p>
</li>
<li>
<p>lifecycle actions</p>
</li>
</ul>
<pre><code class="language-js">import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

const url = 'https://course-api.com/react-useReducer-cart-project';

export const getCartItems = createAsyncThunk('cart/getCartItems', () =&gt; {
    return fetch(url)
        .then((resp) =&gt; resp.json())
        .catch((err) =&gt; console.log(error));
});

const cartSlice = createSlice({
    name: 'cart',
    initialState,
    extraReducers: {
        [getCartItems.pending]: (state) =&gt; {
            state.isLoading = true;
        },
        [getCartItems.fulfilled]: (state, action) =&gt; {
            console.log(action);
            state.isLoading = false;
            state.cartItems = action.payload;
        },
        [getCartItems.rejected]: (state) =&gt; {
            state.isLoading = false;
        }
    }
});
</code></pre>
<ul>
<li>App.js</li>
</ul>
<pre><code class="language-js">import { calculateTotals, getCartItems } from './features/cart/cartSlice';

function App() {
    const { cartItems, isLoading } = useSelector((state) =&gt; state.cart);

    useEffect(() =&gt; {
        dispatch(getCartItems());
    }, []);

    if (isLoading) {
        return (
            &lt;div className="loading"&gt;
                &lt;h1&gt;Loading...&lt;/h1&gt;
            &lt;/div&gt;
        );
    }

    return (
        &lt;main&gt;
            {isOpen &amp;&amp; &lt;Modal /&gt;}
            &lt;Navbar /&gt;
            &lt;CartContainer /&gt;
        &lt;/main&gt;
    );
}

export default App;
</code></pre>
<h4 id="options"><a class="header" href="#options">Options</a></h4>
<pre><code class="language-sh">npm install axios
</code></pre>
<ul>
<li>cartSlice.js</li>
</ul>
<pre><code class="language-js">export const getCartItems = createAsyncThunk(
    'cart/getCartItems',
    async (name, thunkAPI) =&gt; {
        try {
            // console.log(name);
            // console.log(thunkAPI);
            // console.log(thunkAPI.getState());
            // thunkAPI.dispatch(openModal());
            const resp = await axios(url);

            return resp.data;
        } catch (error) {
            return thunkAPI.rejectWithValue('something went wrong');
        }
    }
);
</code></pre>
<h4 id="the-extrareducers-builder-callback-notation"><a class="header" href="#the-extrareducers-builder-callback-notation">The extraReducers "builder callback" notation</a></h4>
<p>cart/cartSlice</p>
<pre><code class="language-js">const cartSlice = createSlice({
    name: 'cart',
    initialState,
    reducers: {
        // reducers
    },
    extraReducers: (builder) =&gt; {
        builder
            .addCase(getCartItems.pending, (state) =&gt; {
                state.isLoading = true;
            })
            .addCase(getCartItems.fulfilled, (state, action) =&gt; {
                // console.log(action);
                state.isLoading = false;
                state.cartItems = action.payload;
            })
            .addCase(getCartItems.rejected, (state, action) =&gt; {
                console.log(action);
                state.isLoading = false;
            });
    }
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-i"><a class="header" href="#node-i">Node I</a></h1>
<blockquote>
<p>What is nodejs ?</p>
</blockquote>
<ul>
<li>Environment to run JS outside browser</li>
<li>Built on chromes V8 engine</li>
<li>Both Frontend and Backend can be written in javascript</li>
<li>It provides a way to build scalable and high-performance applications using JavaScript on the server-side</li>
</ul>
<blockquote>
<p>Difference b/w Browser js &amp; NodeJS</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Browser js</th><th>nodejs</th></tr></thead><tbody>
<tr><td>Acess to browser APIs like DOM,window object</td><td>No access to browser APIs</td></tr>
<tr><td>Use to make Interactive Apps</td><td>Use to make Server side Apps</td></tr>
<tr><td>No filesystem</td><td>Has access to filesystem</td></tr>
<tr><td>Depends on users browser's version</td><td>Depends on NodeJS version</td></tr>
<tr><td>ES6 modules</td><td>CommonJS</td></tr>
</tbody></table>
</div>
<h3 id="globals"><a class="header" href="#globals">Globals</a></h3>
<ul>
<li>__dirname - path to current directory</li>
<li>__filename - file name</li>
<li>require - function to use modules (CommonJS)</li>
<li>module - info about current module (file)</li>
<li>process - info about env where the program is being executed</li>
</ul>
<blockquote>
<p>What are modules in nodejs ?</p>
</blockquote>
<p>Modules in Node.js are reusable pieces of code that can
be imported and used in other parts of a program</p>
<ul>
<li>Encapsulated Code (only sahre minimum)</li>
<li>Every file in NodeJS is module by default</li>
</ul>
<h3 id="packagejson-vs-package-lockjson"><a class="header" href="#packagejson-vs-package-lockjson">package.json vs package-lock.json</a></h3>
<ul>
<li>
<p>package.json describes the project's dependencies at a high level</p>
</li>
<li>
<p>package-lock.json provides a detailed record of the exact versions of those dependencies
that were installed. This can help prevent version conflicts and ensure consistent
behavior across different development environments.</p>
</li>
</ul>
<h3 id="modules"><a class="header" href="#modules">Modules</a></h3>
<p><strong>Example to show module export import</strong></p>
<blockquote>
<p>utils.js</p>
</blockquote>
<pre><code class="language-js">// Exporting with custom name

module.exports.name = 'johndoe';

// Exporting directly

module.exports = { name: 'johndoe', id: 3 };

// Returns an object with many properties but we are interested in exports property

console.log(module);
</code></pre>
<p><strong>Note: Whenever we import a module we execute the module</strong></p>
<blockquote>
<p>app.js</p>
</blockquote>
<pre><code class="language-js">const data = require('./utils');

// Will return all the things in exports
console.log(data);
</code></pre>
<h3 id="common-inbuilt-modules"><a class="header" href="#common-inbuilt-modules">Common inbuilt modules</a></h3>
<ul>
<li>os</li>
<li>path</li>
<li>fs</li>
<li>http</li>
</ul>
<h4 id="path-module-basics"><a class="header" href="#path-module-basics">Path module basics</a></h4>
<pre><code class="language-js">const path = require('path');

// returns platform specific path delimter
// For Windows -&gt; \
// For Linux,Mac,BSD -&gt; /
console.log(path.sep);

// Joins the path with platform specific delimeter
const filePath = path.join(`${path.sep}folder`, 'subfolder', 'test.txt');
console.log(filePath);

// Get basename [end name]
console.log(path.basename(filePath));

// Absolute path

// Returns directory of package.json of current project
console.log(__dirname);
console.log(path.resolve(__dirname, 'folder', 'subfolder', 'test.txt'));
</code></pre>
<h4 id="fs-sync-module"><a class="header" href="#fs-sync-module">fs sync module</a></h4>
<pre><code class="language-js">const { readFileSync, writeFileSync } = require('fs');
console.log('start');
const first = readFileSync('./content/first.txt', 'utf8');
const second = readFileSync('./content/second.txt', 'utf8');

writeFileSync(
    './content/result-sync.txt',
    `Here is the result : ${first}, ${second}`,
    { flag: 'a' }
);
console.log('done with this task');
console.log('starting the next one');
</code></pre>
<h4 id="fs-async-module"><a class="header" href="#fs-async-module">fs async module</a></h4>
<pre><code class="language-js">const { writeFile, readFile } = require('fs');

console.log('Start ..');

readFile('./content/first.txt', 'utf-8', (err, res) =&gt; {
    if (err) {
        console.log(err);
        return;
    }
    const first = res;
    console.log(first);
    readFile('./content/second.txt', 'utf-8', (err, res) =&gt; {
        if (err) {
            console.log(err);
            return;
        }
        const sec = res;
        console.log(sec);
        writeFile(
            './content/result-async.txt',
            `${first} ${sec}`,
            {
                flag: 'a'
            },
            (err, res) =&gt; {
                if (err) {
                    return;
                }
                console.log('done with the task');
            }
        );
    });
});

console.log('End');
</code></pre>
<h4 id="http-module"><a class="header" href="#http-module">HTTP Module</a></h4>
<p><strong>Note : Must use end connection otherwise page wull not paint</strong></p>
<pre><code class="language-js">const http = require('http');

const server = http.createServer((req, res) =&gt; {
    if (req.url === '/') {
        res.write('Home Page');
        res.end();
    } else if (req.url === '/about') {
        res.end(`
            &lt;h1&gt; About Page&lt;/h1 &gt;
        `);
    } else {
        res.end(
            `&lt;h1&gt;Page does not exists! &lt;a href="/"&gt;Go back to Home Page&lt;/a&gt;&lt;/h1&gt;`
        );
    }
});

server.listen(5000, () =&gt; {
    console.log('Server started ....');
});
</code></pre>
<h3 id="event-loop"><a class="header" href="#event-loop">Event loop</a></h3>
<p>The event loop is a mechanism in Node.js that allows it to handle multiple requests and operations
simultaneously. It continuously checks for new events or tasks in the queue and executes them one
by one. This ensures that Node.js can handle a large number of requests without blocking the main
thread, making it highly efficient and scalable.</p>
<p>JavaScript is an interpreted language, and it executes code from top to bottom. In JavaScript,
we have the call stack, callbacks, and Web APIs. When code execution starts, it adds everything
one by one to the call stack. Whenever it encounters timeouts, fetch, interval functions, or other
asynchronous operations that take some time to complete, it removes those from the call stack and
puts them into the Web API, which waits for the task to finish. After the task is finished executing,
it is pushed into the task queue (also known as the callback queue), and the event loop takes all the
tasks from the task queue and pushes them to the call stack, where they are executed.</p>
<h3 id="inbuilt-promisify-function-in-nodejs"><a class="header" href="#inbuilt-promisify-function-in-nodejs">Inbuilt promisify function in NodeJS</a></h3>
<pre><code class="language-js">NodeJS -&gt; Inbuilt function util.promisify or use .promise
</code></pre>
<h3 id="event-emitter"><a class="header" href="#event-emitter">Event Emitter</a></h3>
<p>EventEmitter is a built-in module in Node.js that allows you to
create objects that can emit and listen for events.</p>
<pre><code class="language-js">// get back the class
// if want custom extend from class
// otherwise just for emitting and handling events create instance
const EventEmitter = require('events');

const customEmitter = new EventEmitter();

// on and emit methods
// keep track of the order
// additional arguments
// built-in modules utilize it

customEmitter.on('response', (name, id) =&gt; {
    console.log(`data recieved user ${name} with id:${id}`);
});

customEmitter.on('response', () =&gt; {
    console.log('some other logic here');
});

customEmitter.emit('response', 'john', 34);
</code></pre>
<h3 id="streams"><a class="header" href="#streams">Streams</a></h3>
<blockquote>
<p>Extends emitter class</p>
</blockquote>
<ul>
<li>Read and write sequentially</li>
<li>Manipulate or read a big file</li>
</ul>
<p>They allow you to read and write data in chunks,
rather than all at once, which can be more efficient
for large amounts of data.</p>
<blockquote>
<p>Types</p>
</blockquote>
<ul>
<li>Writeable</li>
<li>Readable</li>
<li>DUpleax</li>
<li>Transform</li>
</ul>
<blockquote>
<p>Create a big file</p>
</blockquote>
<pre><code class="language-js">const { writeFileSync } = require('fs');
for (let i = 0; i &lt; 10000; i++) {
    writeFileSync('./content/big.txt', `hello world ${i}\n`, { flag: 'a' });
}
</code></pre>
<blockquote>
<p>Stream example</p>
</blockquote>
<pre><code class="language-js">const { createReadStream } = require('fs');

// default chunk size -&gt; 64kb
// highWaterMark - control size [Specify chunk size]
// Specify encoding to output in human readable
const stream = createReadStream('./content/big.txt', {
    encoding: 'utf8',
    highWaterMark: 9000
});

stream.on('data', (res) =&gt; {
    console.log(res);
});

stream.on('error', (err) =&gt; console.log(err));
</code></pre>
<blockquote>
<p>Stream HTTP</p>
</blockquote>
<pre><code class="language-js">var http = require('http');
var fs = require('fs');

http.createServer(function (req, res) {
    // const text = fs.readFileSync('./content/big.txt', 'utf8')
    // res.end(text)
    const fileStream = fs.createReadStream('./content/big.txt', 'utf8');
    fileStream.on('open', () =&gt; {
        fileStream.pipe(res);
    });
    fileStream.on('error', (err) =&gt; {
        res.end(err);
    });
}).listen(5000);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-ii"><a class="header" href="#node-ii">Node II</a></h1>
<p><strong>Difference b/w res.end() vs res.send()</strong></p>
<div class="table-wrapper"><table><thead><tr><th>res.end()</th><th>res.send()</th></tr></thead><tbody>
<tr><td>Used to end the response and send a body as response</td><td>used to send a response body</td></tr>
<tr><td>Cannot set header and status code</td><td>Automatically sets content-type header based on the data passed as an argument</td></tr>
<tr><td>Immediately terminates the connection with client</td><td>Waits for the response to be send and then terminates the connection</td></tr>
<tr><td>Cannot do this</td><td>Sets Eh-tag header which is used for cache validation</td></tr>
<tr><td>Used to end the response stream and flush any remaining data to the client synchronously. It does not return a promise.</td><td>Used to send data to the client asynchronously. It returns a promise that resolves when the data has been sent.</td></tr>
</tbody></table>
</div>
<h3 id="request"><a class="header" href="#request">Request</a></h3>
<p>Contains:</p>
<ul>
<li><strong>METHODS</strong></li>
<li><strong>URLS (endpoint/Resource to access)</strong></li>
<li><strong>Headers</strong></li>
<li><strong>Body(optional)</strong></li>
</ul>
<h3 id="response"><a class="header" href="#response">Response</a></h3>
<p>Contains:</p>
<ul>
<li><strong>Headers</strong></li>
<li><strong>Status code</strong></li>
<li><strong>Status message</strong></li>
<li><strong>Body(optional)</strong></li>
</ul>
<h3 id="reference"><a class="header" href="#reference">Reference</a></h3>
<ul>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">Common HTTPCodes</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types">Common Mimetypes</a></p>
</li>
</ul>
<blockquote>
<p>What are headers in browser?</p>
</blockquote>
<p><strong>Headers contain important information such as the type of browser being used,
the language preferences of the user, the type of content being requested,
and any cookies or authentication tokens that may be required.</strong></p>
<h3 id="simple-http-server"><a class="header" href="#simple-http-server">Simple HTTP server</a></h3>
<pre><code class="language-js">const http = require('http');

const server = http.createServer((req, res) =&gt; {
    // Write header
    res.writeHead(200, { 'content-type': 'text/html' });

    // Write response body
    res.write('&lt;h1&gt;hello&lt;/h1&gt;');

    // End connection after body and response have been sent to the client
    res.end();
});

server.listen(5000, () =&gt; {
    console.log('Started!');
});
</code></pre>
<h3 id="reading-html-file"><a class="header" href="#reading-html-file">Reading HTML File</a></h3>
<pre><code class="language-js">const http = require('http');
const { readFileSync } = require('fs');

// Will be initialized only at server start and will not block
const somePage = readFileSync('path-to-html-file');

const server = http.createServer((req, res) =&gt; {
    console.log(req.url);
    // Write header
    res.writeHead(200, 'Doneman!', { 'content-type': 'text/html' });

    // Write response body
    res.write('&lt;h1&gt;hello&lt;/h1&gt;');

    // End connection after body and response have been sent to the client
    res.end();
});

server.listen(5000, () =&gt; {
    console.log('Started!');
});
</code></pre>
<h3 id="using-without-express"><a class="header" href="#using-without-express">Using without express</a></h3>
<blockquote>
<p>We need to handle all thr routing by ourselves,handle the locations of the static assets like css,js in our server etc,mention headers by ourselves.</p>
</blockquote>
<pre><code class="language-js">const http = require('http');
const { readFileSync } = require('fs');

// get all files
const homePage = readFileSync('./navbar-app/index.html');
const homeStyles = readFileSync('./navbar-app/styles.css');
const homeImage = readFileSync('./navbar-app/logo.svg');
const homeLogic = readFileSync('./navbar-app/browser-app.js');

const server = http.createServer((req, res) =&gt; {
    // console.log(req.method)
    const url = req.url;
    console.log(url);
    // home page
    if (url === '/') {
        res.writeHead(200, { 'content-type': 'text/html' });
        res.write(homePage);
        res.end();
    }
    // about page
    else if (url === '/about') {
        res.writeHead(200, { 'content-type': 'text/html' });
        res.write('&lt;h1&gt;about page&lt;/h1&gt;');
        res.end();
    }
    // styles
    else if (url === '/styles.css') {
        res.writeHead(200, { 'content-type': 'text/css' });
        res.write(homeStyles);
        res.end();
    }
    // image/logo
    else if (url === '/logo.svg') {
        res.writeHead(200, { 'content-type': 'image/svg+xml' });
        res.write(homeImage);
        res.end();
    }
    // logic
    else if (url === '/browser-app.js') {
        res.writeHead(200, { 'content-type': 'text/javascript' });
        res.write(homeLogic);
        res.end();
    }
    // 404
    else {
        res.writeHead(404, { 'content-type': 'text/html' });
        res.write('&lt;h1&gt;page not found&lt;/h1&gt;');
        res.end();
    }
});

server.listen(5000);
</code></pre>
<blockquote>
<p>Why use express js</p>
</blockquote>
<ul>
<li><strong>Provides us with many robust set of features</strong></li>
<li><strong>Handles routing</strong></li>
<li><strong>Provides us with many HTTP methods which we can use .</strong></li>
<li><strong>Provides us with middlewares.</strong></li>
</ul>
<h3 id="simple-express-app"><a class="header" href="#simple-express-app">Simple Express App</a></h3>
<pre><code class="language-js">const express = require('express');

const app = express();

// USE GET method
app.get('/', (req, res) =&gt; {
    res.status(200).send('&lt;h1&gt;hello&lt;/h1&gt;');
});

// res.all() is a method that sets up a route to handle all HTTP methods (GET, POST, PUT, DELETE, etc.) for a given path.
app.all('*', (req, res) =&gt; {
    res.status(404).send('&lt;h3&gt;Not Found&lt;/h3&gt;');
});

// Keep Listening for requests
app.listen(5000, () =&gt; {
    console.log('Listening .....');
});
</code></pre>
<h3 id="static-assests"><a class="header" href="#static-assests">Static assests</a></h3>
<ul>
<li>
<p><strong>If we do SSR we do not need to mention the index.html if our public folder has index.html as express will Automatically serve that file.</strong>
<strong>We can uncomment the lines path-to-index.</strong></p>
</li>
<li>
<p><strong>Note 1: For every <code>endpoints we must configure the corresponding methods allowed for it</code>
For example: if there is a route <code>/api/gt/gtx</code> we must define what to expect when there is
a get request,post request If there is <code>a get request we can display a html page</code> or if there
is <code>a post request we can respond back with json data</code>.</strong></p>
</li>
<li>
<p><strong>Note 2: Just keep in mind that staic assests are accesible via base root.Suppose in the
public folder we have folder css-&gt;fir.css.We can access it via &lt;domain&gt;/css/fir.css.
Just give the correct relative path in the html files.</strong></p>
</li>
</ul>
<pre><code class="language-js">const express = require('express');
const path = require('path');

const app = express();

// Make static files available by using below middleware
app.use(express.static('path-to-public-folder'));

// USE GET method
app.get('/', (req, res) =&gt; {
    res.sendFile(path.resolve(__dirname, 'path-to-index.html for this page'));
});

// res.all() is a method that sets up a route to handle all HTTP methods (GET, POST, PUT, DELETE, etc.) for a given path.
app.all('*', (req, res) =&gt; {
    res.status(404).send('&lt;h3&gt;Not Found&lt;/h3&gt;');
});

// Keep Listening for requests
app.listen(5000, () =&gt; {
    console.log('Listening .....');
});
</code></pre>
<h3 id="reading-files-and-then-sending"><a class="header" href="#reading-files-and-then-sending">Reading files and then sending</a></h3>
<pre><code class="language-js">const express = require('express');
const { readFileSync } = require('fs');

const data = readFileSync('./public/sec.html', 'utf8');
console.log(data);

const app = express();

app.use(express.static('./public'));
app.get('/', (req, res) =&gt; {
    res.send(data);
});

app.listen(5000, (req, res) =&gt; {
    console.log('Started ....');
});
</code></pre>
<h3 id="api-vs-ssr-difference"><a class="header" href="#api-vs-ssr-difference">API vs SSR difference</a></h3>
<div class="table-wrapper"><table><thead><tr><th>API</th><th>SSR</th></tr></thead><tbody>
<tr><td>We send data through json</td><td>We send data through templates</td></tr>
<tr><td>We use res.json()</td><td>We use res.render()</td></tr>
</tbody></table>
</div>
<h3 id="route-params"><a class="header" href="#route-params">Route Params</a></h3>
<pre><code class="language-js">const express = require('express');

const app = express();

app.get('/', (req, res) =&gt; {
    res.send('&lt;h1&gt;hello&lt;/h1&gt;');
});

// Single Route parameter
app.get('/api/v1/:productID', (req, res) =&gt; {
    // Get the route parameter (Slug)
    // Will be an object -&gt; {productID:3}
    console.log(req.params);

    return res.send('hello');
});

// Multiple Route parameters
app.get('/api/v1/:productID/review/:reviewID', (req, res) =&gt; {
    // Get the route parameter (Slug)
    // Will be an object -&gt; {productID:3,reviewID:3}
    console.log(req.params);

    return res.send('hello');
});

app.listen(5000, (req, res) =&gt; {
    console.log('Started ....');
});
</code></pre>
<h3 id="query-string"><a class="header" href="#query-string">Query String</a></h3>
<pre><code class="language-js">const express = require('express');

const app = express();

app.get('/', (req, res) =&gt; {
    res.send('&lt;h1&gt;hello&lt;/h1&gt;');
});

// Query String
app.get('/api/v1/query', (req, res) =&gt; {
    // on Putting-&gt; http://localhost:5000/api/v1/query?name=hello&amp;id=3
    // {name:"hello",id:3}
    console.log(req.query);

    return res.send('hello');
});

app.listen(5000, (req, res) =&gt; {
    console.log('Started ....');
});
</code></pre>
<h3 id="middlewares"><a class="header" href="#middlewares">Middlewares</a></h3>
<blockquote>
<p>What are middlewares in nodejs</p>
</blockquote>
<ul>
<li>
<p><strong>function that sits between the client and server and performs some operations on the incoming request or outgoing response.</strong></p>
</li>
<li>
<p><strong>It can modify the request/response, add new properties to them, or perform some other tasks before passing them to the next middleware</strong></p>
</li>
<li>
<p><strong>Middleware is used to handle common tasks such as authentication,</strong>
<strong>logging, error handling, and more.</strong></p>
</li>
<li>
<p><strong>handles a specific task or set of tasks during the</strong>
<strong>request-response cycle of an HTTP server</strong></p>
</li>
</ul>
<blockquote>
<p>Middleware basics</p>
</blockquote>
<pre><code class="language-js">const express = require('express');

const app = express();

// Express will pass the req,res,next to this middleware function automatically
const logger = (req, res, next) =&gt; {
    // Appending a useful value to request object
    req.user = 'johndoe';

    // Pass the control to the next middlewares
    next();
};

app.get('/', logger, (req, res) =&gt; {
    // Printing what middleware appended
    console.log(req.user);
    res.send('&lt;h1&gt;hello&lt;/h1&gt;');
});

app.listen(5000, (req, res) =&gt; {
    console.log('Started ....');
});
</code></pre>
<blockquote>
<p>Multi Middleware</p>
</blockquote>
<pre><code class="language-js">const express = require('express');

const app = express();

// Express will pass the req,res,next to this middleware function automatically
const logger = (req, res, next) =&gt; {
    console.log('Logger1');

    // Pass the control to the next middlewares
    next();
};

const logger2 = (req, res, next) =&gt; {
    console.log('Logger2');

    // Pass the control to the next middlewares
    next();
};

// Array is used for multi middlewares
app.get('/', [logger, logger2], (req, res) =&gt; {
    res.send('&lt;h1&gt;hello&lt;/h1&gt;');
});

app.listen(5000, (req, res) =&gt; {
    console.log('Started ....');
});
</code></pre>
<blockquote>
<p>All Routes Middleware</p>
</blockquote>
<pre><code class="language-js">const express = require('express');

const app = express();

const logger = (req, res, next) =&gt; {
    console.log(req.url);
    next();
};

// Will be used by all routes
app.use(logger);

app.get('/', (req, res) =&gt; {
    res.send('&lt;h1&gt;hello&lt;/h1&gt;');
});

app.get('/api/hello', (req, res) =&gt; {
    res.send('&lt;h1&gt;hello&lt;/h1&gt;');
});

app.get('/api/hello/world', (req, res) =&gt; {
    res.send('&lt;h1&gt;hello&lt;/h1&gt;');
});

app.all('*', (req, res) =&gt; {
    res.send('&lt;h1&gt;not found!&lt;/h1&gt;');
});

app.listen(5000, (req, res) =&gt; {
    console.log('Started ....');
});
</code></pre>
<blockquote>
<p>Route specific Middleware</p>
</blockquote>
<pre><code class="language-js">const express = require('express');

const app = express();

const logger = (req, res, next) =&gt; {
    console.log(req.url);
    next();
};

// Will be used by all routes starting with "/api"
app.use('/api', logger);

app.get('/', (req, res) =&gt; {
    res.send('&lt;h1&gt;hello&lt;/h1&gt;');
});

app.get('/xyz', (req, res) =&gt; {
    res.send('&lt;h1&gt;hello&lt;/h1&gt;');
});

// logger will be used here
app.get('/api/hello', (req, res) =&gt; {
    res.send('&lt;h1&gt;hello&lt;/h1&gt;');
});

// logger will be used here
app.get('/api/hello/world', (req, res) =&gt; {
    res.send('&lt;h1&gt;hello&lt;/h1&gt;');
});

app.all('*', (req, res) =&gt; {
    res.send('&lt;h1&gt;not found!&lt;/h1&gt;');
});

app.listen(5000, (req, res) =&gt; {
    console.log('Started ....');
});
</code></pre>
<h3 id="http-methods"><a class="header" href="#http-methods">HTTP Methods</a></h3>
<pre><code class="language-js">const express = require('express');

const app = express();

app.get('/', (req, res) =&gt; {
    res.send('&lt;h1&gt;hello&lt;/h1&gt;');
});

// parse json [Javascript/Postman type submitted data]
app.use(express.json());

// Post request specific
app.post('/api/people', (req, res) =&gt; {
    // Will print the json send from Postman type app
    console.log(req.body);
    res.status(201).json(req.body);
});

app.listen(5000, (req, res) =&gt; {
    console.log('Started ....');
});
</code></pre>
<p><strong>Note : Try using a MVC (Model View Controller to structure node projects)</strong></p>
<h3 id="express-router"><a class="header" href="#express-router">Express router</a></h3>
<p><strong>Note: Create a folder named routes</strong></p>
<blockquote>
<p>router-people.js</p>
</blockquote>
<pre><code class="language-js">const express = require('express');
const router = express.Router();

const {
    getPeople,
    createPerson,
    createPersonPostman,
    updatePerson,
    deletePerson
} = require('../controllers/people');

router.get('/', getPeople);
router.post('/', createPerson);
router.post('/postman', createPersonPostman);
router.put('/:id', updatePerson);
router.delete('/:id', deletePerson);

router.route('/').get(getPeople).post(createPerson);
router.route('/postman').post(createPersonPostman);
router.route('/:id').put(updatePerson).delete(deletePerson);

module.exports = router;
</code></pre>
<h3 id="express-controllers"><a class="header" href="#express-controllers">Express controllers</a></h3>
<p><strong>Note: Create a folder named controllers</strong></p>
<pre><code class="language-js">// No need to import anything

const createPerson = (req, res) =&gt; {
    const { name } = req.body;
    if (!name) {
        return res
            .status(400)
            .json({ success: false, msg: 'please provide name value' });
    }
    res.status(201).send({ success: true, person: name });
};

module.exports = {
    createPerson
};
</code></pre>
<blockquote>
<p>app.js</p>
</blockquote>
<pre><code class="language-js">const express = require('express');
const app = express();

const people = require('./routes/people');
const auth = require('./routes/auth');

// static assets
app.use(express.static('./methods-public'));
// parse form data
app.use(express.urlencoded({ extended: false }));
// parse json
app.use(express.json());

app.use('/api/people', people);
app.use('/login', auth);

app.listen(5000, () =&gt; {
    console.log('Server is listening on port 5000....');
});
</code></pre>
<h3 id="sending-cookies-with-expressjs"><a class="header" href="#sending-cookies-with-expressjs">Sending Cookies with expressJS</a></h3>
<pre><code class="language-js">res.cookie('name', 'john', {
    httpOnly: true,
    sameSite: 'strict',
    maxAge: 2 * 3600 * 1000
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-basic-app-with-nodejsprisma"><a class="header" href="#a-basic-app-with-nodejsprisma">A Basic App with nodejs+prisma</a></h1>
<h3 id="install-express-and-prisma"><a class="header" href="#install-express-and-prisma">Install express and prisma</a></h3>
<pre><code class="language-sh">npm i @prisma/client express dotenv nodemon
</code></pre>
<h3 id="add-to-packagejson"><a class="header" href="#add-to-packagejson">Add to package.json</a></h3>
<pre><code class="language-json">"scripts": {
    "dev": "nodemon index.js"
},
</code></pre>
<h3 id="initialize-prisma-project"><a class="header" href="#initialize-prisma-project">Initialize Prisma project</a></h3>
<pre><code class="language-sh">npx prisma init
</code></pre>
<h3 id="env-variables"><a class="header" href="#env-variables">ENV Variables</a></h3>
<pre><code>DATABASE_URL="postgresql://postgres:@localhost:5432/postdb?schema=public"
CHECKPOINT_DISABLE=1
</code></pre>
<blockquote>
<p>Documentation Links</p>
</blockquote>
<ul>
<li>
<p><a href="https://www.prisma.io/docs/orm/reference/prisma-cli-reference">cli Reference</a></p>
</li>
<li>
<p><a href="https://www.prisma.io/docs/orm/reference/prisma-client-reference">client Reference</a></p>
</li>
</ul>
<h2 id="modelschema"><a class="header" href="#modelschema">Model/Schema</a></h2>
<blockquote>
<p>prisma/schema.prisma</p>
</blockquote>
<pre><code class="language-prisma">generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User{
    id Int @id @default(autoincrement())
    email String
    posts Post[]
}

model Post{
    id Int @id @default(autoincrement())
    updatedAt DateTime @default(now())
    createdAt DateTime @updatedAt
    title String @db.VarChar(255)
    desc String @db.Text()
    author User @relation(fields: [authorId],references: [id])
    authorId Int
}
</code></pre>
<blockquote>
<p>Run migration</p>
</blockquote>
<pre><code class="language-sh">npx prisma migrate dev --name init
</code></pre>
<h2 id="controllers"><a class="header" href="#controllers">Controllers</a></h2>
<blockquote>
<p>controllers/posts.js</p>
</blockquote>
<pre><code class="language-js">const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

const createPost = async (req, res) =&gt; {
    const result = await prisma.post.create({
        data: req.body
    });
    res.json(result);
};

const updatePost = async (req, res) =&gt; {
    const result = await prisma.post.findFirst({
        where: { id: parseInt(req.params.id) }
    });

    if (result) {
        const result = await prisma.post.update({
            where: { id: parseInt(req.params.id) },
            data: req.body
        });
        return res.json(result);
    }
    return res.json({ msg: 'No Such Record!' });
};

const deletePost = async (req, res) =&gt; {
    const result = await prisma.post.findFirst({
        where: { id: parseInt(req.params.id) }
    });
    if (result) {
        const result = await prisma.post.delete({
            where: { id: parseInt(req.params.id) }
        });
        return res.json(result);
    }
    return res.json({ msg: 'No Such Record!' });
};

const getAllPost = async (req, res) =&gt; {
    const result = await prisma.post.findMany();
    res.json(result);
};

const getPost = async (req, res) =&gt; {
    console.log(req.params.id);
    const result = await prisma.post.findMany({
        where: { id: parseInt(req.params.id) }
    });
    res.json(result);
};

module.exports = { createPost, updatePost, deletePost, getAllPost, getPost };
</code></pre>
<h2 id="routes"><a class="header" href="#routes">Routes</a></h2>
<blockquote>
<p>routes/posts.js</p>
</blockquote>
<pre><code class="language-js">const {
    getPost,
    getAllPost,
    createPost,
    updatePost,
    deletePost
} = require('../controllers/post');

const express = require('express');
const router = express.Router();

// Get all post
router.get('/', getAllPost);

// Get post by id [with path parameter]
router.get('/:id', getPost);

// Create post
router.post('/', createPost);

// Update post
router.put('/:id', updatePost);

// Delete post
router.delete('/:id', deletePost);

module.exports = router;
</code></pre>
<h2 id="app"><a class="header" href="#app">App</a></h2>
<blockquote>
<p>index.js</p>
</blockquote>
<pre><code class="language-js">const express = require('express');
const dotenv = require('dotenv');
const post = require('./routes/post');

dotenv.config();
const app = express();

app.use(express.json());
app.use('/api/v1/post', post);

app.listen(5000, () =&gt; {
    console.log('hello');
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphql-basics-with-apolloserver-and-nodejs"><a class="header" href="#graphql-basics-with-apolloserver-and-nodejs">GraphQL Basics with Apolloserver and nodeJS</a></h1>
<h3 id="install-dependencies"><a class="header" href="#install-dependencies">Install Dependencies</a></h3>
<pre><code class="language-sh">npm i @apollo/server graphql nodemon
</code></pre>
<h3 id="add-to-packagejson-1"><a class="header" href="#add-to-packagejson-1">Add to package.json</a></h3>
<pre><code class="language-json">"scripts": {
    "dev": "nodemon index.js"
},
</code></pre>
<h3 id="basic-apolloserver-with-hello-query"><a class="header" href="#basic-apolloserver-with-hello-query">Basic Apolloserver with hello query</a></h3>
<pre><code class="language-js">const { ApolloServer } = require('@apollo/server');
const { startStandaloneServer } = require('@apollo/server/standalone');

// Type Definations
const typeDefs = `#graphql
    type Query{
    hello:String!
    }
`;

// Function to call for queries and mutations
const resolvers = {
    Query: {
        hello: () =&gt; 'hello'
    }
};

// Start Apollo Server
const run = async () =&gt; {
    const server = new ApolloServer({ typeDefs, resolvers });
    const { url } = await startStandaloneServer(server, {
        listen: { port: 4000 }
    });
    return url;
};

run()
    .then((url) =&gt; {
        console.log(`Started Server at ${url}`);
    })
    .catch((err) =&gt; {
        console.log(err);
    });
</code></pre>
<h3 id="basics-of-queries-and-mutations"><a class="header" href="#basics-of-queries-and-mutations">Basics of queries and mutations</a></h3>
<pre><code class="language-js">const { ApolloServer } = require('@apollo/server');
const { startStandaloneServer } = require('@apollo/server/standalone');

// Type Definations [Schema]
const typeDefs = `#graphql

    # Normal Types
    type Errors{
    msg:String!
    code:Int!
    }

    type RegisterResponse{
    email:String
    password:String
    errors:[Errors]
    }

    type User{
    email:String
    password:String
    }

    # Input Type
    input UserInfo{
    email:String
    password:String
    }

    # Query Type [Used for quering,filtering,fetching]
    type Query{
    hello:String!
    getall:[User]
    }

    # Mutation type [Used for updating,creating,deleting]
    type Mutation{
    # Normal Way of taking input/arguments
    # register(email:String!,password:String!):RegisterResponse

    # Taking input/arguments using objects
    register(userinfo:UserInfo):RegisterResponse
    }

`;

// Function to call for queries and mutations
const resolvers = {
    Query: {
        hello: () =&gt; 'hello',
        getall: () =&gt; {
            return [{ email: 'asd', password: 'dsa' }];
        }
    },
    Mutation: {
        register: () =&gt; {
            return {
                email: 'xyz',
                password: 'xuz',
                errors: [{ msg: 'hello', code: 201 }]
            };
        }
    }
};

// Start Apollo Server
const run = async () =&gt; {
    const server = new ApolloServer({ typeDefs, resolvers });
    const { url } = await startStandaloneServer(server, {
        listen: { port: 4000 }
    });
    return url;
};

run()
    .then((url) =&gt; {
        console.log(`Started Server at ${url}`);
    })
    .catch((err) =&gt; {
        console.log(err);
    });
</code></pre>
<h3 id="resolver-arguments"><a class="header" href="#resolver-arguments">Resolver arguments</a></h3>
<blockquote>
<p>In Apollo GraphQL each resolver has access to 4 args which are as follows:</p>
</blockquote>
<ul>
<li>parent : Parent object value of the previous resolver.</li>
<li>args : Arguments passed to this resolver</li>
<li>context : A global value accesible to all resolvers.A custom object each resolver can read from/write to.</li>
<li>info : Parsed GraphQL query , mutation , subscription string [AST of the incoming request]</li>
</ul>
<pre><code class="language-js">const { ApolloServer } = require('@apollo/server');
const { startStandaloneServer } = require('@apollo/server/standalone');

// Type Definations [Schema]
const typeDefs = `#graphql

    # Normal Types
    type Errors{
    msg:String!
    code:Int!
    }

    type RegisterResponse{
    email:String
    password:String
    errors:[Errors]
    }

    type User{
    email:String
    password:String
    }

    # Input Type
    input UserInfo{
    email:String
    password:String
    }

    # Query Type [Used for quering,filtering,fetching]
    type Query{
    hello:String!
    getall:[User]
    }

    # Mutation type [Used for updating,creating,deleting]
    type Mutation{
    # Normal Way of taking input/arguments
    # register(email:String!,password:String!):RegisterResponse

    # Taking input/arguments using objects
    register(userinfo:UserInfo):RegisterResponse
    }

`;

// Function to call for queries and mutations
const resolvers = {
    User: {
        // We can have resolver for email too i.e. what to do when we see email [PARENT]
        email: (parent) =&gt; {
            console.log(parent);
            return parent.email.toUpperCase();
        }
    },
    Query: {
        hello: () =&gt; 'hello',
        getall: () =&gt; {
            return [{ email: 'asd', password: 'dsa' }];
        }
    },
    Mutation: {
        // Resolvers fn can be async
        register: async (parent, args, ctx, info) =&gt; {
            console.log(info); // [info]
            console.log(args); // [args]
            return {
                email: 'xyz',
                password: 'xuz',
                errors: [{ msg: 'hello', code: 201 }]
            };
        }
    }
};

// Start Apollo Server
const run = async () =&gt; {
    const server = new ApolloServer({ typeDefs, resolvers });
    const { url } = await startStandaloneServer(server, {
        listen: { port: 4000 },
        // Passing context [CONTEXT]
        context: async ({ req, res }) =&gt; {
            return { name: 'asd', id: '1' };
        }
    });
    return url;
};

run()
    .then((url) =&gt; {
        console.log(`Started Server at ${url}`);
    })
    .catch((err) =&gt; {
        console.log(err);
    });
</code></pre>
<h3 id="fragments-and-aliases"><a class="header" href="#fragments-and-aliases">Fragments and aliases</a></h3>
<pre><code class="language-gql">{
Userl: user(id: 1) {

...userFields

}

User2: user(id: 2) {
...userFields

}

i

fragment userFields on Person {
name
email

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript"><a class="header" href="#typescript">Typescript</a></h1>
<h2 id="typescript-basics"><a class="header" href="#typescript-basics">Typescript Basics</a></h2>
<h3 id="compiling"><a class="header" href="#compiling">Compiling</a></h3>
<pre><code class="language-sh">tsc &lt;name_of_file&gt;
</code></pre>
<h3 id="variables"><a class="header" href="#variables">Variables</a></h3>
<pre><code class="language-ts">// Explicit type defination

// Number
const a: Number = 5.45;

// Objects
interface User {
    name: String;
    id?: Number; // Optional Field
}

const obj: User = {
    name: 'asda'
};

// Adding the id field later
obj.id = 2;
</code></pre>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<pre><code class="language-ts">type AddFunc = (x: number, y: number) =&gt; number;

const add1: AddFunc = (x: number, y: number) =&gt; {
    return x + y;
};

const add2 = (obj: { a: number; b: number }) =&gt; {
    return obj.a + obj.b;
};
</code></pre>
<h3 id="unions"><a class="header" href="#unions">Unions</a></h3>
<pre><code class="language-ts">// Unions Types
const fn = (x: string | number) =&gt; x;

console.log(fn('sad'));
console.log(fn(11));

interface Cat {
    purr: string;
}

interface Dog {
    bark: string;
}

type dog_cat = (Cat &amp; Dog) | number;

let obj: dog_cat = {
    purr: 'purr',
    bark: 'bark'
};

obj = 5;
</code></pre>
<h3 id="casting"><a class="header" href="#casting">Casting</a></h3>
<pre><code class="language-ts">// Use &lt;&gt; angular brackets
let a = 5;
console.log(&lt;number&gt;a);

// Use "as" keyword for casting
console.log(a as number);
</code></pre>
<h3 id="any"><a class="header" href="#any">Any</a></h3>
<pre><code class="language-ts">// Input any data-type and return data as any datatype
const fn = (x: any): any =&gt; x;
</code></pre>
<h2 id="typescript-nodejs"><a class="header" href="#typescript-nodejs">Typescript NodeJS</a></h2>
<h3 id="install-dependencies-1"><a class="header" href="#install-dependencies-1">Install Dependencies</a></h3>
<pre><code class="language-sh">npm init -y
npm i typescript --save-dev
npm i @types/node --save-dev
npm i nodemon ts-node --save-dev
npx tsc --init
</code></pre>
<h3 id="note"><a class="header" href="#note">Note</a></h3>
<ul>
<li><strong>Files with cts must be imported with cjs [es5 using files exporting using module.exports]</strong></li>
<li><strong>Files with ts must be imported with js [es6 using files]</strong></li>
</ul>
<blockquote>
<p>package.json</p>
</blockquote>
<pre><code class="language-json">"type": "module",
"scripts": {
    "build": "tsc",
    "start": "tsc --watch &amp; node --watch dist/index.js"
},
</code></pre>
<blockquote>
<p>tsconfig.json</p>
</blockquote>
<pre><code class="language-json">{
    "compilerOptions": {
        "module": "NodeNext", // NodeNext (ES6), Commonjs (ES5)
        "moduleResolution": "NodeNext",
        "esModuleInterop": true,
        "target": "ES5", // Javascript version our ts code will be compiled to
        "sourceMap": true,
        "outDir": "dist",
        "rootDir": "src"
    },
    "include": ["src/**/*"]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs--apollo-graphql--typescript--postgressql"><a class="header" href="#nodejs--apollo-graphql--typescript--postgressql">NodeJS + Apollo GraphQL + Typescript + PostgresSQL</a></h1>
<h3 id="install-dependencies-2"><a class="header" href="#install-dependencies-2">Install Dependencies</a></h3>
<pre><code class="language-sh">npm init -y
npm i typescript @types/node --save-dev
npm i @apollo/server graphql dotenv @types/dotenv
npm i nodemailer @types/nodemailer
touch tsconfig.json
npx prisma init
</code></pre>
<p>** Add the following to below files : **</p>
<blockquote>
<p>tsconfig.json</p>
</blockquote>
<pre><code class="language-json">{
    "compilerOptions": {
        "module": "NodeNext", // NodeNext (ES6), Commonjs (ES5)
        "moduleResolution": "NodeNext",
        "esModuleInterop": true,
        "target": "ES5", // Javascript version our ts code will be compiled to
        "sourceMap": true,
        "outDir": "dist",
        "rootDir": "src"
    },
    "include": ["src/**/*"]
}
</code></pre>
<blockquote>
<p>package.json</p>
</blockquote>
<pre><code class="language-json">"type": "module",
"scripts": {
    "build": "tsc",
    "start": "tsc --watch &amp; node --watch dist/index.js"
},
</code></pre>
<blockquote>
<p>prisma/schema.prisma</p>
</blockquote>
<pre><code class="language-prisma">// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User{
    id Int @id @default(autoincrement())
    name String
    email String
    password String
    posts Post[]
}

model Post{
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    title String
    desc String
    author User @relation(fields: [authorid], references:[id])
    authorid Int
}
</code></pre>
<blockquote>
<p>Run migrations</p>
</blockquote>
<pre><code class="language-sh">npx prisma migrate dev --name init
</code></pre>
<h3 id="main-app"><a class="header" href="#main-app">Main App</a></h3>
<blockquote>
<p>src/index.ts</p>
</blockquote>
<pre><code class="language-ts">import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone';
import { config } from 'dotenv';
import { typeDefs } from './schema.js';
import { resolvers } from './resolvers.js';

config();

const run = async () =&gt; {
    const server = new ApolloServer({ typeDefs, resolvers });
    const { url } = await startStandaloneServer(server, {
        listen: {
            port: 4000
        }
    });
    return url;
};

run()
    .then((url) =&gt; {
        console.log(`Started Server at ${url}`);
    })
    .catch((err) =&gt; {
        console.log(err);
    });
</code></pre>
<blockquote>
<p>src/schema.ts</p>
</blockquote>
<pre><code class="language-ts">export const typeDefs = `#graphql
    type User{
        id:ID
        name:String
        email:String
    }

    type Post{
        id:ID
        createdAt : String
        updatedAt : String
        title: String
        desc: String
        authorid:ID

    }

    type Query{
        getalluser:[User]
        getuserbyid(id:ID):User
        getallposts:[Post]
        getpostbyauthor(id:ID):[Post]
        getpostbyid(id:ID):Post
    }

    type resp  {
        err:Error
        user:User
    }

    type Error{
        msg:String!
    }

    input registerinfo{
        name:String!
        email:String!
        password:String!
    }

    input logininfo{
        email:String!
        password:String!
    }

    input createpostinfo{
        authorid:ID!
        title:String!
        desc:String!
    }

    input updatepostinfo{
        postid:ID!
        title:String
        desc:String
    }

    input resetpass{
        id:ID!
        email:String!
        password:String!
    }


    type Mutation{
        register(userinfo:registerinfo):resp
        login(logininfo:logininfo):resp
        createpost(info:createpostinfo):Post
        updatepost(upinfo:updatepostinfo):Post
        deletepost(id:ID):Post
        sendforgetpassmail(email:String!):Boolean
        resetpassword(info:resetpass):resp
    }

`;
</code></pre>
<blockquote>
<p>src/resolvers.ts</p>
</blockquote>
<pre><code class="language-ts">import { PrismaClient } from '@prisma/client';
import nodemailer from 'nodemailer';

const prisma = new PrismaClient();

export const resolvers = {
    Query: {
        getalluser: async () =&gt; {
            const data = await prisma.user.findMany({
                select: {
                    id: true,
                    name: true,
                    email: true
                }
            });
            return data;
        },
        getuserbyid: async (_, { id }) =&gt; {
            const data = await prisma.user.findFirst({
                select: {
                    id: true,
                    name: true,
                    email: true
                },
                where: {
                    id: parseInt(id)
                }
            });
            return data;
        },
        getallposts: async () =&gt; {
            const data = await prisma.post.findMany({
                select: {
                    id: true,
                    createdAt: true,
                    updatedAt: true,
                    title: true,
                    desc: true,
                    authorid: true
                }
            });
            return data;
        },
        getpostbyauthor: async (_, { id }) =&gt; {
            const data = await prisma.post.findMany({
                select: {
                    id: true,
                    createdAt: true,
                    updatedAt: true,
                    title: true,
                    desc: true,
                    authorid: true
                },
                where: {
                    authorid: parseInt(id)
                }
            });
            return data;
        },
        getpostbyid: async (_, { id }) =&gt; {
            const data = await prisma.post.findFirst({
                select: {
                    id: true,
                    createdAt: true,
                    updatedAt: true,
                    title: true,
                    desc: true,
                    authorid: true
                },

                where: { id: parseInt(id) }
            });
            return data;
        }
    },
    Mutation: {
        register: async (_, { userinfo: { name, email, password } }) =&gt; {
            // Check user exist
            const finduser = await prisma.user.findFirst({
                select: {
                    id: true,
                    name: true,
                    email: true
                },
                where: { email: email }
            });
            if (finduser) {
                return {
                    user: null,
                    err: {
                        msg: 'Email exists! Please use a different email address!'
                    }
                };
            } else {
                const user = await prisma.user.create({
                    data: {
                        email,
                        name,
                        password
                    }
                });
                return {
                    user: {
                        id: user.id,
                        name: user.name,
                        email: user.email
                    },
                    err: null
                };
            }
        },
        login: async (_, { logininfo: { email, password } }) =&gt; {
            // Check user exist
            const finduser = await prisma.user.findFirst({
                select: {
                    id: true,
                    name: true,
                    email: true
                },
                where: { email: email, password: password }
            });
            if (!finduser) {
                return {
                    user: null,
                    err: {
                        msg: 'Please enter correct email and password!'
                    }
                };
            } else {
                return {
                    user: {
                        id: finduser.id,
                        name: finduser.name,
                        email: finduser.email
                    },
                    err: null
                };
            }
        },
        createpost: async (_, { info: { authorid, title, desc } }) =&gt; {
            const createpost = await prisma.post.create({
                data: {
                    title,
                    desc,
                    authorid: parseInt(authorid)
                }
            });
            return {
                id: createpost.id,
                createdAt: createpost.createdAt,
                updatedAt: createpost.updatedAt,
                title: createpost.title,
                desc: createpost.desc,
                authorid: createpost.authorid
            };
        },
        updatepost: async (_, { upinfo: { postid, title, desc } }) =&gt; {
            const updatepost = await prisma.post.update({
                where: {
                    id: parseInt(postid)
                },
                data: {
                    title,
                    desc
                }
            });

            return {
                id: updatepost.id,
                createdAt: updatepost.createdAt,
                updatedAt: updatepost.updatedAt,
                title: updatepost.title,
                desc: updatepost.desc,
                authorid: updatepost.authorid
            };
        },
        deletepost: async (_, { id }) =&gt; {
            const updatepost = await prisma.post.delete({
                where: {
                    id: parseInt(id)
                }
            });

            return {
                id: updatepost.id,
                createdAt: updatepost.createdAt,
                updatedAt: updatepost.updatedAt,
                title: updatepost.title,
                desc: updatepost.desc,
                authorid: updatepost.authorid
            };
        },
        sendforgetpassmail: async (_, { email }) =&gt; {
            // Only needed if you don't have a real mail account for testing
            // let testAccount = await nodemailer.createTestAccount();
            // console.log(testAccount);

            // Future -&gt; Check if user exists and then only send mail

            let user = 'q3oqwlgga4verudl@ethereal.email';
            let pass = 'RHXPUjDXYjnAGsG98e';

            // create reusable transporter object using the default SMTP transport
            let transporter = nodemailer.createTransport({
                host: 'smtp.ethereal.email',
                port: 587,
                secure: false, // true for 465, false for other ports
                auth: {
                    user: user, // generated ethereal user
                    pass: pass // generated ethereal password
                }
            });

            // send mail with defined transport object
            let info = await transporter.sendMail({
                from: `${user}`, // sender address
                to: 'bar@example.com, baz@example.com', // list of receivers
                subject: 'Hello ✔', // Subject line
                text: 'Hello world?', // plain text body
                html: '&lt;b&gt;Hello world?&lt;/b&gt;', // html body
                attachments: [
                    {
                        filename: 'hello.json',
                        content: JSON.stringify({
                            name: 'Hello World!'
                        })
                    }
                ]
            });
            console.log('Message sent: %s', info.messageId);

            // Preview only available when sending through an Ethereal account
            console.log('Preview URL: %s', nodemailer.getTestMessageUrl(info));

            return true;
        },
        resetpassword: async (_, { info: { email, password, id } }) =&gt; {
            const finduser = await prisma.user.update({
                where: {
                    email,
                    id: parseInt(id)
                },
                data: {
                    password
                }
            });
            return {
                user: {
                    id: finduser.id,
                    name: finduser.name,
                    email: finduser.email
                },
                err: null
            };
        }
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql"><a class="header" href="#sql">SQL</a></h1>
<ul>
<li>Domain Specific (Can be used in RDBMS only)</li>
<li>Declarative Language (We have to mention just what to do not how to do)</li>
</ul>
<h2 id="types-of-sql-commands"><a class="header" href="#types-of-sql-commands">Types of SQL commands</a></h2>
<ul>
<li>DDL (Works with schema/structure) : CREATE,ALTER,DROP</li>
<li>DML (Works with data inside the database schema) : INSERT,UPDATE,DELETE,SELECT</li>
<li>DCL (Works with authorization purposes) : GRANT , REVOKE</li>
<li>TCL (Transcation realated) : COMMIT , ROLLBACK , SAVEPOINTS</li>
</ul>
<h3 id="create-table"><a class="header" href="#create-table">CREATE table</a></h3>
<p>Link : https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-create-table/</p>
<pre><code class="language-sql">CREATE TABLE [IF NOT EXISTS] table_name (
   column1 datatype(length) column_contraint,
   column2 datatype(length) column_contraint,
   column3 datatype(length) column_contraint,
   table_constraints
);

</code></pre>
<h3 id="insert-into-table"><a class="header" href="#insert-into-table">INSERT into table</a></h3>
<p>Link : https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-insert/</p>
<pre><code class="language-sql">
INSERT INTO table_name(column1, column2, …)
VALUES (value1, value2, …);
</code></pre>
<h3 id="alter-table"><a class="header" href="#alter-table">ALTER TABLE</a></h3>
<p>Link : https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-alter-table/</p>
<pre><code class="language-sql">ALTER TABLE table_name action;
</code></pre>
<h3 id="update"><a class="header" href="#update">UPDATE</a></h3>
<p>Link : https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-update/</p>
<pre><code class="language-sql">UPDATE table_name
SET column1 = value1,
    column2 = value2,
    ...
WHERE condition;
</code></pre>
<h3 id="difference-bw-alter-and-update"><a class="header" href="#difference-bw-alter-and-update">Difference b/w ALTER and UPDATE</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ALTER</th><th>UPDATE</th></tr></thead><tbody>
<tr><td>DDL</td><td>DML</td></tr>
<tr><td>Works with structure schema</td><td>Works with change in data</td></tr>
<tr><td>Example : Renaming a column,Changing datatype of a column,droping a column</td><td>Update a value inside the column.</td></tr>
<tr><td>No condition</td><td>Can give condition with where clause</td></tr>
</tbody></table>
</div>
<h3 id="delete"><a class="header" href="#delete">DELETE</a></h3>
<p>Link : https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-delete/</p>
<pre><code class="language-sql">DELETE FROM table_name
WHERE condition;
</code></pre>
<h3 id="drop"><a class="header" href="#drop">DROP</a></h3>
<p>Link : https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-drop-table/</p>
<pre><code class="language-sql">DROP TABLE [IF EXISTS] table_name
[CASCADE | RESTRICT];
</code></pre>
<h3 id="truncate"><a class="header" href="#truncate">TRUNCATE</a></h3>
<p>Link : https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-truncate-table/</p>
<pre><code class="language-sql">TRUNCATE TABLE table_name;
</code></pre>
<h3 id="difference-bw-deletedroptruncate"><a class="header" href="#difference-bw-deletedroptruncate">Difference b/w DELETE,DROP,TRUNCATE</a></h3>
<div class="table-wrapper"><table><thead><tr><th>DELETE</th><th>DROP</th><th>TRUNCATE</th></tr></thead><tbody>
<tr><td>DML</td><td>DDL</td><td>DDL</td></tr>
<tr><td>Deletes only rows row</td><td>Deletes every row+schema</td><td>Deletes only rows</td></tr>
<tr><td>Deletes rows one by one (can give where clause)</td><td>-</td><td>Deletes rows in one go</td></tr>
<tr><td>Slower, Rollback possible if done before commit as it maintains logs</td><td>-</td><td>Faster, Rollback not possible as it maintains no logs</td></tr>
</tbody></table>
</div>
<h3 id="constraints"><a class="header" href="#constraints">Constraints</a></h3>
<ul>
<li><code>UNIQUE</code> (For unique values)</li>
<li><code>NOT NULL</code> (non-empty values)</li>
<li><code>PRIMARY KEY</code> (Unique + not null values)</li>
<li><code>FOREIGN KEY</code> (Maintains Referential Integrity)</li>
<li><code>CHECK</code> (Suppose we want to check the age of person during registration process in a website before inserting into the table)</li>
<li><code>DEFAULT</code> (default values if we do not give any values)</li>
</ul>
<h2 id="architectures-in-database"><a class="header" href="#architectures-in-database">Architectures in Database</a></h2>
<h3 id="1-tier-architecture"><a class="header" href="#1-tier-architecture">1 tier architecture</a></h3>
<ul>
<li>Only database layer</li>
<li>Example : MS Office,Paint,Photoshop</li>
</ul>
<h3 id="2-tier-architecture"><a class="header" href="#2-tier-architecture">2 tier architecture</a></h3>
<ul>
<li>Client layer &amp; database layer</li>
<li>Not scalable,not secure</li>
<li>Heavy load on database layer</li>
<li>Example : Suppose we go to a bank to create an account,we fill the form then give the accountant the form
and then accountant from his/her client machine will register our details or in this case data is pushed
to the database layer.</li>
</ul>
<h3 id="3-tier-architecture"><a class="header" href="#3-tier-architecture">3 tier architecture</a></h3>
<ul>
<li>Client layer , Application/Business layer , &amp; database layer</li>
<li>scalable,secure</li>
<li>Example : Suppose we we use the official bank mobile app (acts as an interface) to create an account ,then all the details will
first go to the Application/Business layer where the details will be processed and then data is pushed into the database layer.</li>
</ul>
<h2 id="different-keys"><a class="header" href="#different-keys">Different Keys</a></h2>
<h3 id="candidate-keys"><a class="header" href="#candidate-keys">Candidate keys</a></h3>
<p><strong>Set of keys/attributes which have the potential of being the primary key (Uniqe + can be null)</strong></p>
<p>Example : voter id, social security number, phone number can be the candidates for being primary keys</p>
<h3 id="primary-keys"><a class="header" href="#primary-keys">Primary keys</a></h3>
<p>Used to uniquely identify tuples in a table (Unique + not null)</p>
<p><b> Note : There can only be one primary key per table.</b></p>
<h3 id="foreign-keys"><a class="header" href="#foreign-keys">Foreign keys</a></h3>
<p>It is an attribute or set of attribute which references the primary key of same or another table.
Primarily Used for maintaining referential integrity.</p>
<p>Link : https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-foreign-key/</p>
<pre><code class="language-sql">[CONSTRAINT fk_name]
   FOREIGN KEY(fk_columns)
   REFERENCES parent_table(parent_key_columns)
   [ON DELETE delete_action]
   [ON UPDATE update_action]
</code></pre>
<p><b>Parent Table (Referenced Table)</b></p>
<ul>
<li>Insert : No violation</li>
<li>Update and Delete : May cause violation</li>
</ul>
<p><b>Child Table (Referencing Table)</b></p>
<ul>
<li>Insert : May cause Violation</li>
<li>Delete : No violation</li>
<li>Update : May cause violation</li>
</ul>
<p><b>PostgreSQL supports the following actions:</b></p>
<ul>
<li>SET NULL</li>
<li>SET DEFAULT</li>
<li>RESTRICT</li>
<li>NO ACTION</li>
<li>CASCADE</li>
</ul>
<p><b> Note : There can only be more than one foreign key per table.</b></p>
<h3 id="difference-between-restrict-and-no-action"><a class="header" href="#difference-between-restrict-and-no-action">Difference between RESTRICT and NO ACTION</a></h3>
<p>RESTRICT blocks updates that would violate the referential integrity of the constraint, while NO ACTION allows updates to proceed without enforcing the constraint.</p>
<h3 id="super-key"><a class="header" href="#super-key">Super Key</a></h3>
<p>Supeset of any candidate key (all possible values to uniquely identify two tuples in a table)</p>
<p>Formula : 2^n-k-(2^n-commonsets) , k no of candiate keys</p>
<h3 id="difference-bw-nested-subqueries--correlated-subqueries"><a class="header" href="#difference-bw-nested-subqueries--correlated-subqueries">Difference b/w Nested Subqueries , Correlated Subqueries</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Nested</th><th>Correlated</th></tr></thead><tbody>
<tr><td>Inner query runs first once and acts as a result for the outer query</td><td>Outer query runs first and for each outer query inner query runs multiple times</td></tr>
<tr><td>Example : IN , NOT IN</td><td>Example : EXISTS , NOT EXISTS</td></tr>
<tr><td>Bottom up approach</td><td>Top Down approach</td></tr>
</tbody></table>
</div>
<h3 id="common-things-to-do"><a class="header" href="#common-things-to-do">Common things to do</a></h3>
<ul>
<li>Aggreagte Functions</li>
<li>Nested,Correlated [Subqueries]</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>IN , NOT IN</li>
<li>EXISTS , NOT EXISTS</li>
</ul>
<h3 id="varchar-vs-varchar2"><a class="header" href="#varchar-vs-varchar2">Varchar vs Varchar2</a></h3>
<ul>
<li>Varchar is ANSI standard</li>
<li>Varchar2 is Oracles standard</li>
</ul>
<h3 id="acid"><a class="header" href="#acid">ACID</a></h3>
<ul>
<li>Atomicity : Either all changes are performed or none of them.</li>
<li>Consistency : Data is consistent after and before the transcation.</li>
<li>Isolation : Transcation takes place concurrently in an isolated manner.</li>
<li>Durability: After a transcation completes successfuly all the data changes persists even after the events of system failure</li>
</ul>
<h3 id="joins"><a class="header" href="#joins">Joins</a></h3>
<ul>
<li>Cross Join : Cartesian prodocut of 2 tables (combinations of rows of 2 tables).</li>
<li>Self Join : Joininig a table with itself.</li>
<li>Natural Join/Inner Join : Returns records matching in both the tables.</li>
<li>Left Outer Join : Returns the common records in both the tables as well as records not in right table but in left.Fills the columns not in right table with null.</li>
<li>Right Outer Join : Returns the common records in both the tables as well as records not in left table but in right.Fills the columns not in left table with null.</li>
</ul>
<blockquote>
<p>Alternate way of inner join</p>
</blockquote>
<pre><code>select
  pt.patient_id,
  pt.first_name,
  pt.last_name,
  doc.specialty
from
  patients as pt,
  doctors as doc,
  admissions as adm
where
  pt.patient_id = adm.patient_id
  AND adm.attending_doctor_id = doc.doctor_id
  AND adm.diagnosis='Epilepsy'
  AND doc.first_name='Lisa'
</code></pre>
<blockquote>
<p>Inner Joins Syntax</p>
</blockquote>
<pre><code>SELECT
  p.patient_id,
  p.first_name AS patient_first_name,
  p.last_name AS patient_last_name,
  ph.specialty AS attending_doctor_specialty
FROM patients p
  JOIN admissions a ON a.patient_id = p.patient_id
  JOIN doctors ph ON ph.doctor_id = a.attending_doctor_id
WHERE
  ph.first_name = 'Lisa' and
  a.diagnosis = 'Epilepsy'
</code></pre>
<p>Link : https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-joins/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-alchemy"><a class="header" href="#sql-alchemy">SQL Alchemy</a></h1>
<h2 id="install-2"><a class="header" href="#install-2">Install</a></h2>
<pre><code class="language-sh">pip install virtualenv
mkdir sqlalc
cd sqlalc
python -m venv env
source ./env/bin/activate.fish
pip install sqlalchemy asyncio aiosqlite
</code></pre>
<h2 id="sql-alchemy-core"><a class="header" href="#sql-alchemy-core">SQL Alchemy Core</a></h2>
<blockquote>
<p>It is a Low level API which give us more control over the
queries we write. It provides us with the feature of writing raw sql queries.</p>
</blockquote>
<h4 id="connecting-with-a-database"><a class="header" href="#connecting-with-a-database">Connecting with a database</a></h4>
<pre><code class="language-py">from sqlalchemy import create_engine, text

# Initialize engine
DB_URL = "sqlite:///test.db"
engine = create_engine(DB_URL, echo=True)

# Establish connection with the database
with engine.connect() as conn:
    # Execute raw sql query
    statement = text("select 100+200;")
    res = conn.execute(statement)
    print(res.all())
</code></pre>
<h4 id="defining-schema-of-db"><a class="header" href="#defining-schema-of-db">Defining schema of db</a></h4>
<p>In SQLAlchemy Core, the metadata object is used to define the structure of
the database tables and their relationships. It is a container for
all the table definitions and provides a way to introspect the database schema.</p>
<pre><code class="language-py">from sqlalchemy import ForeignKey, MetaData, String, Table, Column, Integer, Text


# MetaData object
meta_obj = MetaData()

### Users Table

"""
Users Table
    - id (pk)
    - name (str)
    - fullname (str)
    - email (str)
"""

user_schema = [
    Column("id", Integer, primary_key=True),
    Column("name", String(30), nullable=False),
    Column("fullname", String(50), nullable=False),
    Column("email", String(30), nullable=False),
]
user_table = Table("users", meta_obj, *user_schema)

### Comments Table

"""
Comments Table
    - id (pk)
    - comment (str)
    - user_id (int,fk refrencing the id in user table)
"""

comments_schema = [
    Column("id", Integer, primary_key=True),
    Column("comment", Text, nullable=False),
    Column("user_id", Integer, ForeignKey("users.id")),
]
comments_table = Table("comments", meta_obj, *comments_schema)
</code></pre>
<h4 id="creating-tables"><a class="header" href="#creating-tables">Creating Tables</a></h4>
<pre><code class="language-py">from connect import engine
from tables import meta_obj


# Create all the tables
meta_obj.create_all(bind=engine)
</code></pre>
<h4 id="inserting-data"><a class="header" href="#inserting-data">Inserting Data</a></h4>
<pre><code class="language-py">from sqlalchemy import insert
from connect import engine
from tables import user_table


with engine.connect() as conn:
    # Insert Single Data
    user = {"name": "John", "fullname": "John Doe", "email": "john@doe.com"}
    statement = insert(user_table).values(**user)
    conn.execute(statement)
    conn.commit()

    # Insert Multiple Data
    users = [
        {"name": "Jake", "fullname": "Jake Doe", "email": "jake@doe.com"},
        {"name": "Joe", "fullname": "Joe Smith", "email": "joe@smith.com"},
    ]

    statement = insert(user_table)
    conn.execute(statement, users)
    conn.commit()
</code></pre>
<h4 id="selecting-data"><a class="header" href="#selecting-data">Selecting Data</a></h4>
<pre><code class="language-py">from sqlalchemy import select
from tables import user_table
from connect import engine


with engine.connect() as conn:
    # Simple select statement
    statement = select(user_table)
    res = conn.execute(statement)
    print(res.all())

    # Select statement with where clause
    statement = select(user_table).where(user_table.c.id == 3)
    res = conn.execute(statement)

    # For priting all rows
    for row in res:
        print(row)
</code></pre>
<h4 id="updating-data"><a class="header" href="#updating-data">Updating Data</a></h4>
<pre><code class="language-py">from sqlalchemy import update
from tables import user_table
from connect import engine


with engine.connect() as conn:
    # Updated Data
    statement = update(user_table).where(user_table.c.id == 1).values(name="Updated")
    conn.execute(statement)
    conn.commit()
</code></pre>
<h4 id="deleting-data"><a class="header" href="#deleting-data">Deleting Data</a></h4>
<pre><code class="language-py">from sqlalchemy import delete
from tables import user_table
from connect import engine


with engine.connect() as conn:
    # Delete data
    statement = delete(user_table).where(user_table.c.id == 1)
    conn.execute(statement)
    conn.commit()
</code></pre>
<h2 id="sqlalchemy-orm"><a class="header" href="#sqlalchemy-orm">SQLAlchemy ORM</a></h2>
<blockquote>
<p>It is a high level API to interact with the database. Here we can define python classes which directly maps to db tables,
providing us a more pythonic way to interact with the database.</p>
</blockquote>
<p>An Object-Relational Mapping (ORM) is a tool or software library that allows programmers to
interact with databases using an object-oriented programming language, rather than writing
SQL queries directly.</p>
<p><strong>Advantages of ORMs</strong>:</p>
<ul>
<li>Simplified database access: ORMs provide a simple and intuitive way to interact with databases, allowing developers to focus on their application logic instead of writing complex SQL queries.</li>
<li>Improved productivity: ORMs reduce the amount of boilerplate code required to perform common database operations, such as creating, reading, updating, and deleting records.</li>
<li>Consistency: ORMs provide a consistent interface for working with different types of databases, making it easier to switch between them or use multiple databases in the same application.</li>
<li>Type safety: ORMs can provide type safety, which means that the compiler can check for errors at compile time instead of runtime, reducing the risk of runtime errors.</li>
<li>Abstraction: ORMs abstract away the underlying database implementation, making it easier to write database-agnostic code.</li>
</ul>
<p><strong>Disadvantages of ORMs</strong>:</p>
<ul>
<li>Performance overhead: ORMs can introduce performance overhead due to the additional layer of abstraction between the application and the database.</li>
<li>Limited query capabilities: ORMs may not support all SQL queries or features, limiting the flexibility of the developer when working with complex data.</li>
<li>Learning curve: ORMs can have a steep learning curve, especially for developers who are new to object-relational mapping.</li>
<li>Complexity: ORMs can add complexity to the application, making it harder to debug and maintain.</li>
<li>Lazy loading: ORMs often use lazy loading to fetch related data only when it's needed, but this can result in multiple round trips to the database, leading to performance issues.</li>
</ul>
<h4 id="connecting-with-a-database-1"><a class="header" href="#connecting-with-a-database-1">Connecting with a database</a></h4>
<pre><code class="language-py">from sqlalchemy import create_engine, text

# Initialize engine
DB_URL = "sqlite:///test.db"
engine = create_engine(DB_URL, echo=True)

# Establish connection with the database
with engine.connect() as conn:
    # Execute raw sql query
    statement = text("select 1+1;")
    res = conn.execute(statement)
    print(res.all())
</code></pre>
<h4 id="defining-schema-of-db-1"><a class="header" href="#defining-schema-of-db-1">Defining schema of db</a></h4>
<pre><code class="language-py">from sqlalchemy import ForeignKey, Integer, String, Text
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship


# Base class
class Base(DeclarativeBase):
    pass


# Users Table


class Users(Base):
    """
    User Table
        - id (pk)
        - name (str)
        - fullname (str)
        - email (str)
    """

    __tablename__ = "users"
    id: Mapped[int] = mapped_column("id", Integer, primary_key=True)
    name: Mapped[str] = mapped_column("name", String(30), nullable=False)
    fullname: Mapped[str] = mapped_column("fullname", String(50), nullable=False)
    email: Mapped[str] = mapped_column("email", String(30), nullable=False)
    comments: Mapped[list["Comments"]] = relationship(
        back_populates="user", cascade="delete,all"
    )

    # def __repr__(self):
    #     return f"Username: {self.fullname} Email: {self.email}"


# Comments Table


class Comments(Base):
    """
    Comment Table
        - id (pk)
        - comment (str)
        - user_id (int,fk referencing the id in user table)
    """

    __tablename__ = "comments"
    id: Mapped[int] = mapped_column("id", Integer, primary_key=True)
    comment: Mapped[str] = mapped_column("comment", Text, nullable=False)
    user_id: Mapped[int] = mapped_column("user_id", Integer, ForeignKey("users.id"))
    user: Mapped[Users] = relationship(back_populates="comments", cascade="delete,all")

    # def __repr__(self):
    #     return f"Comment: {self.comment} Comment By: {self.user.fullname}"
</code></pre>
<h4 id="creating-tables-1"><a class="header" href="#creating-tables-1">Creating Tables</a></h4>
<pre><code class="language-py">from connect import engine
from tables import Base


Base.metadata.create_all(bind=engine)
</code></pre>
<h4 id="inserting-into-table"><a class="header" href="#inserting-into-table">Inserting into Table</a></h4>
<pre><code class="language-py">from sqlalchemy.orm import Session
from tables import Users, Comments
from connect import engine


# Session object
session = Session(bind=engine)


# Insert users
user1 = Users(
    name="John",
    fullname="John Doe",
    email="john@doe.com",
    # comments=[Comments(comment="hello"), Comments(comment="hey there")],
)

# Adding Single User
session.add(user1)
session.commit()


# Adding Multiple User
user2 = Users(
    name="Jake",
    fullname="Jake Smith",
    email="jake@smith.com",
    # comments=[Comments(comment="hello2"), Comments(comment="hey there2")],
)
user3 = Users(
    name="Joe",
    fullname="Joe Smith",
    email="joe@smith.com",
    # comments=[Comments(comment="hello3"), Comments(comment="hey there3")],
)

session.add_all([user2, user3])
session.commit()


# Add a smaple comment
comment1 = Comments(comment="hello world", user_id=1)
session.add(comment1)
session.commit()
</code></pre>
<h4 id="selecting"><a class="header" href="#selecting">Selecting</a></h4>
<pre><code class="language-py">from sqlalchemy import and_, select
from sqlalchemy.orm import Session
from connect import engine
from tables import Users


# Session object
session = Session(bind=engine)


# With ORM

## Simple select statement
res = session.query(Users)

## Simple select with where clause and session execute
statement = select(Users).where(Users.name.in_(["Jake", "Joe"]))
res = session.execute(statement)
print(res.all())

# filter vs filter_by

## Select with filter_by [Takes dict like kwargs keyword arguments for and arguments]
statement = select(Users).filter_by(name="John", id=1)
res = session.execute(statement)
print(res.all())

## Select with filter [for and/or arguments]
statement = select(Users).filter(and_(Users.name == "John", Users.id == 1))
res = session.execute(statement)

## scalar vs one
# + scalar will not raise exception if no rows present
# + one will raise exception if no rows present

## Getting user comment using scalars [can be derefrenced using dot]
for i in res.scalars():
    for comment in i.comments:
        print(comment.comment)
</code></pre>
<h4 id="joining"><a class="header" href="#joining">Joining</a></h4>
<pre><code class="language-py">from sqlalchemy.orm import Session
from connect import engine
from tables import Users, Comments
from sqlalchemy import select

session = Session(bind=engine)

# Left Join
statement = select(Users).join(Comments, Users.id == Comments.user_id)
rs = session.execute(statement)
print(rs.all())
</code></pre>
<h4 id="updating"><a class="header" href="#updating">Updating</a></h4>
<pre><code class="language-py">from sqlalchemy import select
from sqlalchemy.orm import Session
from connect import engine
from tables import Users

session = Session(bind=engine)

# Return None if no results found
res = session.query(Users).filter(Users.id == 1).first()

if res:
    res.name = "newname"
    res.fullname = "New Name"
    session.commit()
</code></pre>
<h4 id="deleting"><a class="header" href="#deleting">Deleting</a></h4>
<pre><code class="language-py">from sqlalchemy import select
from sqlalchemy.orm import Session
from connect import engine
from tables import Users

session = Session(bind=engine)

# Return None if no results found
res = session.query(Users).filter(Users.id == 1).first()

if res:
    session.delete(res)
    session.commit()
</code></pre>
<h2 id="sql-alchemy-coreorm-asyncio"><a class="header" href="#sql-alchemy-coreorm-asyncio">SQL Alchemy [core+orm] asyncio</a></h2>
<h4 id="core"><a class="header" href="#core">Core</a></h4>
<pre><code class="language-py">from sqlalchemy.ext.asyncio import create_async_engine
import asyncio
from sqlalchemy import Integer, MetaData, Table, Column, Text, insert
from sqlalchemy.sql import select


meta_obj = MetaData()
user_table = Table(
    "users",
    meta_obj,
    Column("id", Integer, primary_key=True),
    Column("name", Text, nullable=True),
)


async def main():
    DB_URL = "sqlite+aiosqlite:///test.db"
    engine = create_async_engine(DB_URL, echo=True)

    # can use begin -&gt; auto-commit ater transaction
    async with engine.begin() as conn:
        # Create db

        # meta_obj.create_all(bind=engine) [OLD]

        # [NEW]
        await conn.run_sync(meta_obj.create_all)

        # Insert Data
        statement = insert(user_table).values(name="John Doe")
        await conn.execute(statement)

        # Select Data
        statement = select(user_table)
        res = await conn.execute(statement)
        print(res.all())

    await engine.dispose()


asyncio.run(main())
</code></pre>
<h1 id="note-1"><a class="header" href="#note-1">Note:</a></h1>
<p>In SQLAlchemy, the term "expire on commit" refers to a configuration option for a session object
that determines whether or not the state of objects loaded from the database will be set to
"expired" when a transaction is committed. When an object's state is expired, it means that any
changes made to the object during the transaction will be discarded, and the next time the object is
accessed, its state will be reloaded from the database.</p>
<h4 id="orm"><a class="header" href="#orm">ORM</a></h4>
<pre><code class="language-py">from sqlalchemy import Integer, Text, select
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
import asyncio
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column


class Base(DeclarativeBase):
    pass


class Users(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column("id", Integer, primary_key=True)
    name: Mapped[str] = mapped_column("name", Text, nullable=False)


async def insert_data(sessmaker: async_sessionmaker[AsyncSession]):
    async with sessmaker() as session:
        newuser = Users(name="John Doe")
        session.add(newuser)
        await session.commit()


async def insert_data(sessmaker: async_sessionmaker[AsyncSession]):
    async with sessmaker() as session:
        st = select(Users).filter(Users.name == "John Doe")
        res = await session.execute(st)
        ans = res.scalars().first()

        if ans:
            print(ans.name)


async def main():
    # Initialize engine
    DB_URL = "sqlite+aiosqlite:///test.db"
    engine = create_async_engine(DB_URL, echo=True)

    # Session maker
    # session=Session(bind=engine) [OLD]

    # New
    session = async_sessionmaker(bind=engine, expire_on_commit=False)

    async with engine.begin() as conn:
        # Create db
        await conn.run_sync(Base.metadata.create_all)

    async with engine.connect() as conn:
        # Insert Data
        # await insert_data(session)

        # Select Data
        await insert_data(session)


asyncio.run(main())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis"><a class="header" href="#redis">Redis</a></h1>
<blockquote>
<p>Redis is a memory-based database that is commonly used for caching purposes.
When we have a value that takes a long time to compute, we can cache it in Redis and
retrieve it quickly when we need it. This can significantly improve the performance
of our application by reducing the time it takes to compute the value.</p>
</blockquote>
<h3 id="key-value-pair"><a class="header" href="#key-value-pair">Key Value pair</a></h3>
<pre><code class="language-sh"># Set/Update key value
set name john

# Will return 1 if exists or 0 if not exists and will print the name if exists
get name

# Will return 1 if exists or 0 if not exists and will delete the key if exists
del name

# List all
keys *

# Delete all
flushall

# Get time to live
ttl name

# Set expiry time
EXPIRE name 10

# set with expiry time
setex name 10 john
</code></pre>
<h3 id="lists"><a class="header" href="#lists">Lists</a></h3>
<pre><code class="language-sh"># Push from the left and right
lpush arr john johnny
rpush arr hello hello2

# List all
range arr 0 -1

# Remove from left and right
lpop arr
rpop arr

# delete list
del arr
</code></pre>
<h3 id="sets-store-unique-values"><a class="header" href="#sets-store-unique-values">Sets [store unique values]</a></h3>
<pre><code class="language-sh"># Add to set
SADD hobbies "hello" 1 2

# List all members
SMEMBERS hobbies

# Remove members
SREM hobbies "hello"
</code></pre>
<h3 id="hashes-key-value-pair-inside-of-a-key-value"><a class="header" href="#hashes-key-value-pair-inside-of-a-key-value">Hashes [key value pair inside of a key value]</a></h3>
<p><strong>No nesting allowed.Imagine a JSON object we cannot have json inside json.</strong></p>
<pre><code class="language-sh">
# Set an attribute to hashset person
HSET person name john

# Get a single attribute from hashset person
HGET person name

# Getall attributes from hashset person
HGETALL person

# delete hashset attribute
HDEL person name

# delete hashset
DEL person
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fastapi"><a class="header" href="#fastapi">FastAPI</a></h1>
<h3 id="install-dependencies-3"><a class="header" href="#install-dependencies-3">Install dependencies</a></h3>
<pre><code class="language-sh">pip install fastapi uvicorn sqlalchemy strawberry-graphql[debug-server] asyncio python-dotenv asyncpg
</code></pre>
<h2 id="a-simple-crud-app-using-sqlalchemy-coreasyncpgfastapi"><a class="header" href="#a-simple-crud-app-using-sqlalchemy-coreasyncpgfastapi">A simple crud app using sqlalchemy core,asyncpg,fastapi</a></h2>
<p>.env</p>
<pre><code>DB_URL=postgresql+asyncpg://postgres:@localhost/fastdb
</code></pre>
<blockquote>
<p>main.py</p>
</blockquote>
<pre><code class="language-py">import uvicorn
from fastapi import FastAPI
from sqlalchemy import delete, insert, select, update
from connectdb import engine
from tables import user_table, post_table
from schema import Post, PostBody, updateBody
from connectdb import engine


app = FastAPI()


@app.get("/post", response_model=list[Post])
async def get_all_posts():
    async with engine.connect() as conn:
        st = select(post_table)
        res = await conn.execute(st)
        data = res.scalars()
        return data


@app.get("/post/{id}", response_model=Post)
async def get_post_by_id(id: int):
    async with engine.connect() as conn:
        st = select(post_table).filter_by(id=id)
        res = await conn.execute(st)
        data = res.scalars()
        return data


@app.post("/post")
async def create_post(bd: PostBody):
    async with engine.connect() as conn:
        st = insert(post_table).values(
            title=bd.title, description=bd.description, author_id=bd.aid
        )
        await conn.execute(st)
        await conn.commit()
        return bd


@app.put("/post/{id}")
async def update_post(id: int, bd: updateBody):
    async with engine.connect() as conn:
        st = (
            update(post_table)
            .where(post_table.c.id == id)
            .values(title=bd.title, description=bd.description)
        )
        await conn.execute(st)
        await conn.commit()
        return bd


@app.delete("/post/{id}")
async def delete_post(id: int):
    async with engine.connect() as conn:
        st = delete(post_table).where(post_table.c.id == id)
        await conn.execute(st)
        await conn.commit()
    return {"msg": "Deleted!"}


@app.get("/")
async def hello():
    return {"msg": "hello_world"}


if __name__ == "__main__":
    uvicorn.run("main:app", reload=True, log_level="info", workers=4, port=5000)
</code></pre>
<blockquote>
<p>connectdb.py</p>
</blockquote>
<pre><code class="language-py">from sqlalchemy.ext.asyncio import create_async_engine
import asyncio
from tables import meta_obj
from dotenv import load_dotenv
import os


# Load ENV variables
load_dotenv()

# Engine
engine = create_async_engine(os.getenv("DB_URL"), echo=True)


# Create DB
async def main():
    async with engine.begin() as conn:
        await conn.run_sync(meta_obj.create_all)
        print("Connected to DB...")
    await engine.dispose()


asyncio.run(main())
</code></pre>
<blockquote>
<p>schema.py</p>
</blockquote>
<pre><code class="language-py">from pydantic import BaseModel
from datetime import datetime


class Post(BaseModel):
    id: int
    title: str
    description: str
    createdAt: datetime
    updatedAt: datetime
    author_id: int

    class Config:
        orm_mode = True


class PostBody(BaseModel):
    aid: int
    title: str
    description: str


class updateBody(BaseModel):
    title: str
    description: str
</code></pre>
<blockquote>
<p>tables.py</p>
</blockquote>
<pre><code class="language-py">from sqlalchemy import (
    MetaData,
    Column,
    Table,
    Integer,
    String,
    Text,
    ForeignKey,
    DateTime,
)
from datetime import datetime

meta_obj = MetaData()


# Users table
"""
Users Table
    - id (pk)
    - email (str)
    - password (str)
"""

args = [
    Column("id", Integer, primary_key=True),
    Column("email", String(50), unique=True, nullable=False),
    Column("password", String(50), nullable=False),
]
user_table = Table("users", meta_obj, *args)

# Post table
"""
Posts Table
    - id (pk)
    - title (str)
    - description (str)
    - createdAt(datetime)
    - updatedAt(datetime)
    - author_id (int,fk refrencing the id in user table)
"""

args = [
    Column("id", Integer, primary_key=True),
    Column("title", Text, unique=True, nullable=False),
    Column("description", Text, nullable=False),
    Column("createdAt", DateTime, default=datetime.utcnow),
    Column("updatedAt", DateTime, onupdate=datetime.utcnow),
    Column("author_id", Integer, ForeignKey("users.id")),
]
post_table = Table("posts", meta_obj, *args)
</code></pre>
<h2 id="a-simple-crud-app-using-sqlalchemy-ormasyncpgfastapi"><a class="header" href="#a-simple-crud-app-using-sqlalchemy-ormasyncpgfastapi">A simple crud app using sqlalchemy orm,asyncpg,fastapi</a></h2>
<p>.env</p>
<pre><code>DB_URL=postgresql+asyncpg://postgres:@localhost/fastdb
</code></pre>
<blockquote>
<p>main.py</p>
</blockquote>
<pre><code class="language-py">import uvicorn
from fastapi import FastAPI
from sqlalchemy import delete, insert, select, update
from connectdb import engine
from connectdb import sess
from schema import Post, PostBody, updateBody
from connectdb import engine
from crud import get_all, create_, update_, delete_


app = FastAPI()


@app.get("/post", response_model=list[Post])
async def get_all_posts():
    data = await get_all(sess)
    return data


@app.get("/post/{id}", response_model=Post)
async def get_post_by_id(id: int):
    pass


@app.post("/post", response_model=Post)
async def create_post(bd: PostBody):
    data = await create_(sess, bd)
    return data


@app.put("/post/{id}")
async def update_post(id: int, bd: updateBody):
    data = await update_(sess, bd, id)
    return data


@app.delete("/post/{id}")
async def delete_post(id: int):
    data = await delete_(sess, id)
    return data


@app.get("/")
async def hello():
    return {"msg": "hello_world"}


if __name__ == "__main__":
    uvicorn.run("main:app", reload=True, log_level="info", workers=4, port=5000)
</code></pre>
<blockquote>
<p>connectdb.py</p>
</blockquote>
<pre><code class="language-py">from sqlalchemy import text, create_engine
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
import asyncio
from tables import Base
from dotenv import load_dotenv
import os


# Load ENV variables
load_dotenv()

# Engine
engine = create_async_engine(os.getenv("DB_URL"), echo=True)
sess = async_sessionmaker(bind=engine, expire_on_commit=False)


# Create DB
async def main():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
        print("Connected to DB...")
    await engine.dispose()


asyncio.run(main())
</code></pre>
<blockquote>
<p>tables.py</p>
</blockquote>
<pre><code class="language-py">from sqlalchemy import (
    Integer,
    String,
    Text,
    ForeignKey,
    DateTime,
)
from datetime import datetime
from sqlalchemy.orm import Mapped, mapped_column, DeclarativeBase, relationship


class Base(DeclarativeBase):
    pass


# Users table
"""
Users Table
    - id (pk)
    - email (str)
    - password (str)
"""


class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column("id", Integer, primary_key=True)
    email: Mapped[str] = mapped_column("email", String(50), nullable=False)
    password: Mapped[str] = mapped_column("password", String(50), nullable=False)
    posts: Mapped[list["Post"]] = relationship(
        "Post", back_populates="user", cascade="delete,all"
    )


# Post table
"""
Posts Table
    - id (pk)
    - title (str)
    - description (str)
    - createdAt(datetime)
    - updatedAt(datetime)
    - author_id (int,fk refrencing the id in user table)
"""


class Post(Base):
    __tablename__ = "posts"
    id: Mapped[int] = mapped_column("id", Integer, primary_key=True)
    title: Mapped[str] = mapped_column("title", Text, nullable=False)
    description: Mapped[str] = mapped_column("description", Text, nullable=False)
    createdAt: Mapped[DateTime] = mapped_column(
        "createdAt", DateTime, default=datetime.utcnow
    )
    updatedAt: Mapped[DateTime] = mapped_column(
        "updatedAt", DateTime, onupdate=datetime.utcnow, nullable=True
    )
    user_id: Mapped[int] = mapped_column(
        "user_id", Integer, ForeignKey("users.id"), nullable=False
    )
    user: Mapped[User] = relationship(
        "User", back_populates="posts", cascade="delete,all"
    )
</code></pre>
<blockquote>
<p>schema.py</p>
</blockquote>
<pre><code class="language-py">from pydantic import BaseModel
from datetime import datetime


class Post(BaseModel):
    id: int
    title: str
    description: str
    createdAt: datetime
    user_id: int

    class Config:
        orm_mode = True


class PostBody(BaseModel):
    aid: int
    title: str
    description: str


class updateBody(BaseModel):
    title: str
    description: str
</code></pre>
<blockquote>
<p>crud.py</p>
</blockquote>
<pre><code class="language-py">from sqlalchemy import delete, update
from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker
from sqlalchemy.sql import select
from tables import User, Post


async def get_all(sessmaker: async_sessionmaker[AsyncSession]):
    async with sessmaker() as session:
        st = select(Post)
        res = await session.execute(st)
        return res


async def get_by_id(sessmaker: async_sessionmaker[AsyncSession]):
    async with sessmaker() as session:
        pass


async def create_(sessmaker: async_sessionmaker[AsyncSession], data):
    async with sessmaker() as session:
        newpost = Post(title=data.title, description=data.description)
        newpost.user_id = data.aid

        session.add(newpost)
        await session.commit()
        print(newpost)
        return newpost


async def update_(sessmaker: async_sessionmaker[AsyncSession], data, id):
    async with sessmaker() as session:
        st = select(Post).where(Post.id == id)
        res = await session.execute(st)
        final_data = res.scalar()
        if final_data:
            if data.title:
                final_data.title = data.title
            if data.description:
                final_data.description = data.description
            await session.commit()
        return final_data


async def delete_(sessmaker: async_sessionmaker[AsyncSession], id):
    async with sessmaker() as session:
        print(id)
        st = delete(Post).where(Post.id == id)
        res = await session.execute(st)
        await session.commit()
        return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-hooks-1"><a class="header" href="#react-hooks-1">React Hooks</a></h1>
<p><strong>Basic Hooks</strong></p>
<h2 id="usestate-1"><a class="header" href="#usestate-1">useState</a></h2>
<p><strong>Note : State updates are not immediate.</strong></p>
<blockquote>
<p>Problem</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { useState } from 'react';

const App = () =&gt; {
    const [count, setCount] = useState(0);

    const handleClick = () =&gt; {
        // You may think on every click the value will increase by
        // 3. But it will not because the setCount function is still
        // using the old values of count.In react we need to use the
        // updater function in useState to grab the latest value.

        setCount(count + 1);
        setCount(count + 1);
        setCount(count + 1);
    };

    return (
        &lt;&gt;
            &lt;div&gt;
                &lt;h3&gt;{count}&lt;/h3&gt;
                &lt;button type="button" onClick={handleClick}&gt;
                    Increase
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<blockquote>
<p>Fix</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { useState } from 'react';

const App = () =&gt; {
    const [count, setCount] = useState(0);

    const handleClick = () =&gt; {
        // You may think on every click the value will increase by
        // 3. But it will not because the setCount function is still
        // using the old values of count.In react we need to use the
        // updater function in useState to grab the latest value.

        setCount((prev) =&gt; prev + 1);
        setCount((prev) =&gt; prev + 1);
        setCount((prev) =&gt; prev + 1);
    };

    return (
        &lt;&gt;
            &lt;div&gt;
                &lt;h3&gt;{count}&lt;/h3&gt;
                &lt;button type="button" onClick={handleClick}&gt;
                    Increase
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<blockquote>
<p>Dynamic object Keys form</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { useState } from 'react';

const App = () =&gt; {
    const [data, setData] = useState({ name: '', email: '' });
    const handleChange = (e) =&gt; {
        setData((data) =&gt; {
            return { ...data, [e.target.name]: e.target.value };
        });
    };
    return (
        &lt;div&gt;
            &lt;input
                type="text"
                name="name"
                value={data.name}
                onChange={handleChange}
            /&gt;
            &lt;input
                type="text"
                name="email"
                value={data.email}
                onChange={handleChange}
            /&gt;
        &lt;/div&gt;
    );
};

export default App;
</code></pre>
<h2 id="useeffect-1"><a class="header" href="#useeffect-1">useEffect</a></h2>
<p><strong>Component Mount/Unmount</strong></p>
<ul>
<li>useEffect gets triggered after the page/component in which it is in is rendered.</li>
<li>useEffect cleanup function gets triggered after the component which it is in is unmounted.</li>
</ul>
<blockquote>
<p>App.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { useState } from 'react';
import Hello from './Hello';

const App = () =&gt; {
    const [showhello, setShowhello] = useState(false);
    return (
        &lt;&gt;
            {console.log('App rendered!')}
            {showhello ? &lt;Hello /&gt; : ''}
            &lt;button
                type="button"
                onClick={() =&gt; {
                    setShowhello(!showhello);
                }}
            &gt;
                CLick
            &lt;/button&gt;
            &lt;div&gt;
                &lt;h3&gt;App&lt;/h3&gt;
            &lt;/div&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<blockquote>
<p>Hello.jsx</p>
</blockquote>
<pre><code class="language-js">import React, { useEffect } from 'react';

const Hello = () =&gt; {
    useEffect(() =&gt; {
        console.log(
            'Hello component useEffect is triggered after page has re-rendered!'
        );
        return () =&gt; {
            console.log('Unmounted hello!');
        };
    });

    return (
        &lt;&gt;
            {console.log('Render hello!')}
            &lt;h3&gt;hello&lt;/h3&gt;
        &lt;/&gt;
    );
};

export default Hello;
</code></pre>
<p><strong>Event Listeners in useEffect</strong></p>
<p>Use of cleanup functions.</p>
<ul>
<li>Must cancel the previous event Listeners,otherwise when the component gets
re-rendered we are going to have multiple event-listeners.</li>
</ul>
<blockquote>
<p>App.jsx [Problem and Fix 1]</p>
</blockquote>
<pre><code class="language-js">import React, { useEffect } from 'react';
import { useState } from 'react';
import Hello from './Hello';

const App = () =&gt; {
    const [count, setCount] = useState(0);
    useEffect(() =&gt; {
        // Main
        console.log(
            'This will run after we have painted the DOM with the below JSX'
        );

        // Cleanup [Apprender-&gt;cleanup(if any)-&gt;Trigger useEffect main]
        return () =&gt; {
            console.log('This will run to cancel previous useEffects if any!');
        };
    });
    return (
        &lt;&gt;
            {console.log('App rendered!')}
            {count}
            &lt;button
                type="button"
                onClick={() =&gt; {
                    setCount((prev) =&gt; prev + 1);
                }}
            &gt;
                Click
            &lt;/button&gt;
            &lt;div&gt;
                &lt;h3&gt;App&lt;/h3&gt;
            &lt;/div&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<blockquote>
<p>App.jsx [Problem and Fix 2]</p>
</blockquote>
<pre><code class="language-js">import React, { useEffect } from 'react';
import { useState } from 'react';

const App = () =&gt; {
    const [count, setCount] = useState(0);
    useEffect(() =&gt; {
        // Main
        const fn = () =&gt; {
            console.log('Mouse moved!');
        };

        window.addEventListener('mousemove', fn);

        // Cleanup [Apprender-&gt;cleanup(if any)-&gt;Trigger useEffect main]
        // Going tosave the refrence of function fn of previous useEffect as fn get re-created from scratch
        return () =&gt; {
            window.removeEventListener('mousemove', fn);
        };
    });
    return (
        &lt;&gt;
            {console.log('App rendered!')}
            {count}
            &lt;button
                type="button"
                onClick={() =&gt; {
                    setCount((prev) =&gt; prev + 1);
                }}
            &gt;
                Click
            &lt;/button&gt;
            &lt;div&gt;
                &lt;h3&gt;App&lt;/h3&gt;
            &lt;/div&gt;
        &lt;/&gt;
    );
};

export default App;
</code></pre>
<p><strong>Fetch Function with useEffect using custom hooks</strong></p>
<p>Some note :</p>
<ul>
<li>Custom Hooks can have any arbitary name. Good Convention is
to give the "use" prefix to make the developer understand its
a hook.It is not a mandatory thing.</li>
</ul>
<ul>
<li>UseEffect only runs after dom is painted</li>
<li>Use Dependency array wisely.Below by adding count useEffect is triggerd when value of count changes.</li>
<li>2 phases for a custom default value return phase and value return phase</li>
</ul>
<blockquote>
<p>App.jsx</p>
</blockquote>
<pre><code class="language-js">import React, { useState } from 'react';
import customhook from './customhook';

const App = () =&gt; {
    const [count, setCount] = useState(0);
    const { data, isLoading, isErr } = customhook(count);

    if (isLoading) {
        console.log('Loading renderd!');
        return &lt;div&gt;Loading....&lt;/div&gt;;
    }
    if (isErr) {
        return &lt;div&gt;Error....&lt;/div&gt;;
    }

    return (
        &lt;div&gt;
            {console.log('App renderd!')}
            &lt;h3&gt;Count : {count}&lt;/h3&gt;
            &lt;div&gt;
                &lt;button
                    type="button"
                    onClick={() =&gt; {
                        setCount((prev) =&gt; prev + 1);
                    }}
                &gt;
                    Click
                &lt;/button&gt;
            &lt;/div&gt;
            {data}
        &lt;/div&gt;
    );
};

export default App;
</code></pre>
<blockquote>
<p>customhook.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { useEffect } from 'react';
import { useState } from 'react';

const customhook = (count) =&gt; {
    const [result, setResult] = useState({
        data: [],
        isLoading: true,
        isErr: false
    });

    useEffect(() =&gt; {
        const fetchData = async () =&gt; {
            console.log('customhook effect triggered!');

            try {
                const data = await fetch(
                    `http://numbersapi.com/${count}/trivia`
                );
                const res = await data.text();
                setResult((data) =&gt; {
                    return {
                        ...data,
                        isLoading: false,
                        isErr: false,
                        data: res
                    };
                });
            } catch (err) {
                setResult((data) =&gt; {
                    return {
                        ...data,
                        isLoading: false,
                        isErr: true
                    };
                });
            }
        };
        fetchData();
    }, [count]);

    console.log('customhook renderd!');
    return result;
};

export default customhook;
</code></pre>
<h2 id="useref-1"><a class="header" href="#useref-1">useRef</a></h2>
<blockquote>
<p>Does not trigger re-render and persist the value across multiple re-renders</p>
</blockquote>
<ul>
<li>Keep track of times component re-renderd</li>
<li>Used in forms</li>
</ul>
<p>Note: on adding fetchData function in the above codes Dependency array
,it will cause and infinte loop.We can use useRef to strore the reference
of the function , so on re-render the function does not gets created from
scratch.</p>
<blockquote>
<p>Fix liniting errors</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import { useRef } from 'react';
import { useEffect } from 'react';
import { useState } from 'react';

const customhook = (count) =&gt; {
    const [result, setResult] = useState({
        data: [],
        isLoading: true,
        isErr: false
    });

    // An object with current variable
    // Get created with the first ct value during initial render , so thats wht ct is passed as an argument
    // Can be done with useState too but a function must be returned from a function, state is initialized during first render.

    const fetchData = useRef(async (ct) =&gt; {
        console.log('customhook effect triggered!');

        try {
            const data = await fetch(`http://numbersapi.com/${ct}/trivia`);
            const res = await data.text();
            setResult((data) =&gt; {
                return {
                    ...data,
                    isLoading: false,
                    isErr: false,
                    data: res
                };
            });
        } catch (err) {
            setResult((data) =&gt; {
                return {
                    ...data,
                    isLoading: false,
                    isErr: true
                };
            });
        }
    });

    useEffect(() =&gt; {
        // fetchData();
        fetchData.current(count);
    }, [fetchData.current, count]);

    console.log('customhook renderd!');
    return result;
};

export default customhook;
</code></pre>
<blockquote>
<p>Form example</p>
</blockquote>
<pre><code class="language-js">import React, { useRef } from 'react';

const App = () =&gt; {
    const rf = useRef(null);
    return (
        &lt;div&gt;
            &lt;input
                type="text"
                name="name"
                ref={rf}
                onChange={() =&gt; {
                    console.log(rf.current.value);
                }}
            /&gt;
        &lt;/div&gt;
    );
};

export default App;
</code></pre>
<p><strong>Performance Hooks</strong></p>
<h2 id="reactmemo-1"><a class="header" href="#reactmemo-1">React.memo</a></h2>
<p>In react a child component will re-render if its parent component re-renders,
even if the child components props have not changed.So this can lead to
performace degradation if we have many child components in our app,so
to fix it we can use Reacts memo to tell the component only to re-render when
its props change.But when child component re-renders parent does not re-render,but
the childs child component re-renders.</p>
<h3 id="a-problem-where-child-component-re-renders-even-if-its-props-dont-change-beacuse-its-parent-component-re-renders"><a class="header" href="#a-problem-where-child-component-re-renders-even-if-its-props-dont-change-beacuse-its-parent-component-re-renders">A problem where child component re-renders even if its props dont change beacuse its parent component re-renders</a></h3>
<blockquote>
<p>Problem</p>
</blockquote>
<blockquote>
<p>App.jsx</p>
</blockquote>
<pre><code class="language-js">import React, { useState } from 'react';
import List from './List';

const data = [
    { id: 1, name: 'Jack' },
    { id: 2, name: 'Joe' }
];

const App = () =&gt; {
    const [count, setCount] = useState(0);
    return (
        &lt;div&gt;
            &lt;h3&gt;Count : {count}&lt;/h3&gt;
            &lt;button
                type="button"
                onClick={() =&gt; {
                    setCount((prev) =&gt; prev + 1);
                }}
            &gt;
                Click
            &lt;/button&gt;
            &lt;List people={data} /&gt;
        &lt;/div&gt;
    );
};

export default App;
</code></pre>
<blockquote>
<p>List.jsx</p>
</blockquote>
<pre><code class="language-js">import React from 'react';
import Person from './Person';
const List = ({ people }) =&gt; {
    return (
        &lt;div&gt;
            {people.map((person) =&gt; {
                return &lt;Person key={person.id} {...person} /&gt;;
            })}
        &lt;/div&gt;
    );
};
export default List;
</code></pre>
<blockquote>
<p>Person.jsx</p>
</blockquote>
<pre><code class="language-js">const Person = ({ name }) =&gt; {
    return (
        &lt;div&gt;
            &lt;h4&gt;{name}&lt;/h4&gt;
        &lt;/div&gt;
    );
};
export default Person;
</code></pre>
<blockquote>
<p>Fix</p>
</blockquote>
<p>Move the counter to a seperate component.So that component becomes
a child component of App.jsx when attached to App.jsx.So when counter
renders then the counter and all its child component of counter will re-renders
not app.jsx.</p>
<h3 id="add-reactmemo-will-only-re-render-a-component-if-its-props-have-changed"><a class="header" href="#add-reactmemo-will-only-re-render-a-component-if-its-props-have-changed">Add react.memo() will only re-render a component if its props have changed</a></h3>
<pre><code class="language-js">import React, { useState } from 'react';
import Person from './Person';
const List = ({ people }) =&gt; {
    return (
        &lt;div&gt;
            {people.map((person) =&gt; {
                return &lt;Person key={person.id} {...person} /&gt;;
            })}
        &lt;/div&gt;
    );
};
export default React.memo(List);
</code></pre>
<h2 id="usecallback-1"><a class="header" href="#usecallback-1">useCallback</a></h2>
<blockquote>
<p>Cache a functions reference so that its does not gets created from scratch and its
refrence change</p>
</blockquote>
<p>Tip : Either use Dependency array or set state updater function if want to use latest value of a state.</p>
<blockquote>
<p>App.jsx</p>
</blockquote>
<pre><code class="language-js">import React, { useCallback, useState } from 'react';
import List from './List';

const data = [
    { id: 1, name: 'Jack' },
    { id: 2, name: 'Joe' },
    { id: 3, name: 'Jay' },
    { id: 4, name: 'Jase' }
];

const App = () =&gt; {
    const [count, setCount] = useState(0);
    const [res, setRes] = useState(data);

    const removePerson = useCallback(
        (id) =&gt; {
            // Still going to use the value of res it was first created on initial render
            const data = res.filter((p) =&gt; p.id != id);
            setRes(data);

            // Way 1
            // setRes((prev) =&gt; {
            //     return prev.filter((p) =&gt; p.id != id);
            // });

            // Way 2
        },
        [res]
    );

    return (
        &lt;div&gt;
            &lt;h3&gt;Count : {count}&lt;/h3&gt;
            &lt;button
                type="button"
                onClick={() =&gt; {
                    setCount((prev) =&gt; prev + 1);
                }}
            &gt;
                Click
            &lt;/button&gt;
            &lt;List people={res} removePerson={removePerson} /&gt;
        &lt;/div&gt;
    );
};

export default App;
</code></pre>
<blockquote>
<p>List.jsx</p>
</blockquote>
<pre><code class="language-js">import React, { useState } from 'react';
import Person from './Person';
const List = ({ people, removePerson }) =&gt; {
    return (
        &lt;div&gt;
            {people.map((person) =&gt; {
                return (
                    &lt;Person
                        key={person.id}
                        {...person}
                        removePerson={removePerson}
                    /&gt;
                );
            })}
        &lt;/div&gt;
    );
};
export default React.memo(List);
</code></pre>
<blockquote>
<p>Person.jsx</p>
</blockquote>
<pre><code class="language-js">const Person = ({ name, id, removePerson }) =&gt; {
    return (
        &lt;div&gt;
            &lt;button
                type="button"
                onClick={() =&gt; {
                    removePerson(id);
                }}
            &gt;
                Remove
            &lt;/button&gt;
            &lt;h4&gt;{name}&lt;/h4&gt;
        &lt;/div&gt;
    );
};
export default Person;
</code></pre>
<h2 id="usememo-1"><a class="header" href="#usememo-1">useMemo</a></h2>
<blockquote>
<p>Cache a single value which takes a long time to compute</p>
</blockquote>
<pre><code class="language-js">import React, { useMemo, useState } from 'react';
import { slow } from './slowfunc';

const data = [
    { id: 1, name: 'Jack' },
    { id: 2, name: 'Joe' },
    { id: 3, name: 'Jay' },
    { id: 4, name: 'Jase' }
];

const App = () =&gt; {
    const [count, setCount] = useState(0);

    // Will be run only on first reder

    const val = useMemo(() =&gt; slow(), []);
    console.log(val);

    return (
        &lt;div&gt;
            &lt;h3&gt;Count : {count}&lt;/h3&gt;
            &lt;button
                type="button"
                onClick={() =&gt; {
                    setCount((prev) =&gt; prev + 1);
                }}
            &gt;
                Click
            &lt;/button&gt;
        &lt;/div&gt;
    );
};

export default App;
</code></pre>
<p><strong>Useful Hooks</strong></p>
<h2 id="usecontext-context-api"><a class="header" href="#usecontext-context-api">useContext (Context API)</a></h2>
<blockquote>
<p>main.jsx</p>
</blockquote>
<pre><code class="language-js">import React, { createContext } from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import { BrowserRouter } from 'react-router-dom';

export const userctx = createContext(null);
ReactDOM.createRoot(document.getElementById('root')).render(
    &lt;userctx.Provider value={{ name: 'sdas', id: 1 }}&gt;
        &lt;BrowserRouter&gt;
            &lt;App /&gt;
        &lt;/BrowserRouter&gt;
    &lt;/userctx.Provider&gt;
);
</code></pre>
<blockquote>
<p>About.jsx</p>
</blockquote>
<pre><code class="language-js">import React, { useContext } from 'react';
import { userctx } from '../main';

const About = () =&gt; {
    const val = useContext(userctx);
    console.log(val);
    return &lt;div&gt;About&lt;/div&gt;;
};

export default About;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-typescript"><a class="header" href="#react-typescript">React Typescript</a></h1>
<p>use React.FC to declare component type</p>
<h3 id="props"><a class="header" href="#props">Props</a></h3>
<p>Use interface</p>
<h3 id="hooks"><a class="header" href="#hooks">Hooks</a></h3>
<p>Types are declared using &lt;&gt;</p>
<h3 id="render-props"><a class="header" href="#render-props">Render props</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="nextjs-14"><a class="header" href="#nextjs-14">NextJS 14</a></h3>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p><a href="https://nextjs.org/docs/getting-started/installation">NextJS</a></p>
<h3 id="create-app"><a class="header" href="#create-app">Create APP</a></h3>
<pre><code class="language-sh">npx create-next-app@latest
</code></pre>
<h2 id="folder-structure-1"><a class="header" href="#folder-structure-1">Folder Structure</a></h2>
<ul>
<li>app folder - where we will spend most of our time
<ul>
<li>setup routes, layouts, loading states, etc</li>
</ul>
</li>
<li>node_modules - project dependencies</li>
<li>public - static assets</li>
<li>.gitignore - sets which will be ignored by source control</li>
<li>bunch of config files (will discuss as we go)</li>
<li>in package.json look scripts</li>
<li>'npm run dev' to spin up the project on http://localhost:3000</li>
</ul>
<h2 id="home-page"><a class="header" href="#home-page">Home Page</a></h2>
<ul>
<li>
<p>page.js in the root of app folder</p>
</li>
<li>
<p>represents root of our application
'/' local domain or production domain</p>
</li>
<li>
<p>react component (server component)</p>
</li>
<li>
<p>bunch of css classes (will discuss Tailwind in few lectures)</p>
</li>
<li>
<p>export component as default</p>
</li>
<li>
<p>file name "page" has a special meaning</p>
</li>
<li>
<p>snippets extension</p>
<p>app/page.js</p>
</li>
</ul>
<pre><code class="language-js">const HomePage = () =&gt; {
    return (
        &lt;div&gt;
            &lt;h1 className="text-7xl"&gt;HomePage&lt;/h1&gt;
        &lt;/div&gt;
    );
};
export default HomePage;
</code></pre>
<h2 id="create-pages-in-nextjs"><a class="header" href="#create-pages-in-nextjs">Create Pages in Next.js</a></h2>
<ul>
<li>in the app folder create a folder with the page.js file
<ul>
<li>about/page.js</li>
<li>contact/page.js</li>
</ul>
</li>
<li>can have .js .jsx .tsx extension</li>
</ul>
<p>app/about/page.js</p>
<pre><code class="language-js">const AboutPage = () =&gt; {
    return (
        &lt;div&gt;
            &lt;h1 className="text-7xl"&gt;AboutPage&lt;/h1&gt;
        &lt;/div&gt;
    );
};
export default AboutPage;
</code></pre>
<h2 id="link-component"><a class="header" href="#link-component">Link Component</a></h2>
<ul>
<li>navigate around the project</li>
<li>import Link from 'next/link'
home page</li>
</ul>
<pre><code class="language-js">import Link from 'next/link';

const HomePage = () =&gt; {
    return (
        &lt;div&gt;
            &lt;h1 className="text-7xl"&gt;HomePage&lt;/h1&gt;
            &lt;Link href="/about" className="text-2xl"&gt;
                about page
            &lt;/Link&gt;
        &lt;/div&gt;
    );
};
export default HomePage;
</code></pre>
<h2 id="nested-routes"><a class="header" href="#nested-routes">Nested Routes</a></h2>
<ul>
<li>app/about/info/page.js</li>
<li>if no page.js in a segment will result in 404</li>
</ul>
<pre><code class="language-js">const AboutInfoPage = () =&gt; {
    return &lt;h1 className="text-7xl"&gt;AboutInfoPage&lt;/h1&gt;;
};
export default AboutInfoPage;
</code></pre>
<h2 id="tailwind-and-daisyui"><a class="header" href="#tailwind-and-daisyui">Tailwind and DaisyUI</a></h2>
<p>Tailwind Site : https://tailwindcss.com/docs/installation
DaisyUI Site : https://daisyui.com/components/</p>
<ul>
<li>
<p>both videos optional</p>
</li>
<li>
<p>remove extra code in globals.css</p>
</li>
<li>
<p>install daisyui</p>
</li>
<li>
<p>install tailwindcss typography plugin</p>
</li>
<li>
<p>configure tailwind</p>
</li>
</ul>
<pre><code class="language-sh">npm i -D daisyui@latest
npm i @tailwindcss/typography
</code></pre>
<p>tailwind.config.js</p>
<pre><code class="language-js">/** @type {import('tailwindcss').Config} */
module.exports = {
  ...
  plugins: [require('@tailwindcss/typography'), require('daisyui')]
};

</code></pre>
<h2 id="layouts-and-templates"><a class="header" href="#layouts-and-templates">Layouts and Templates</a></h2>
<ul>
<li>
<p>layout.js</p>
</li>
<li>
<p>template.js</p>
<p>Layout is a component which wraps other pages and layouts. Allow to share UI. Even when the route changes, layout DOES NOT re-render. Can fetch data but can't pass it down to children. Templates are the same but they re-render.</p>
</li>
<li>
<p>the top-most layout is called the Root Layout. This required layout is shared across all pages in an application. Root layouts must contain html and body tags.</p>
</li>
<li>
<p>any route segment can optionally define its own Layout. These layouts will be shared across all pages in that segment.</p>
</li>
<li>
<p>layouts in a route are nested by default. Each parent layout wraps child layouts below it using the React children prop.</p>
</li>
</ul>
<pre><code class="language-js">import { Inter } from 'next/font/google';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata = {
    title: 'Next.js Tutorial',
    description: 'Build awesome stuff with Next.js!'
};

export default function RootLayout({ children }) {
    return (
        &lt;html lang="en"&gt;
            &lt;body className={inter.className}&gt;{children}&lt;/body&gt;
        &lt;/html&gt;
    );
}
</code></pre>
<h2 id="challenge---navbar"><a class="header" href="#challenge---navbar">Challenge - Navbar</a></h2>
<ul>
<li>in the root create components folder</li>
<li>create Navbar.jsx component</li>
<li>import Link component</li>
<li>setup a list of links (to existing pages)</li>
<li>iterate over the list</li>
<li>render Navbar in the app/layout.js</li>
<li>setup the same layout for all pages (hint: wrap children prop)</li>
</ul>
<h2 id="setup-navbar"><a class="header" href="#setup-navbar">Setup Navbar</a></h2>
<p>components/Navbar</p>
<pre><code class="language-js">import Link from 'next/link';
import React from 'react';

const Navbar = () =&gt; {
    const links = [
        { name: 'client', href: '/client' },
        { name: 'drinks', href: '/drinks' },
        { name: 'tasks', href: '/tasks' },
        { name: 'query', href: '/query' }
    ];
    return (
        &lt;nav className="bg-base-300 py-4"&gt;
            &lt;div className="navbar px-8 max-w-6xl mx-auto flex-col sm:flex-row"&gt;
                &lt;ul className="menu menu-horizontal md:ml-8"&gt;
                    &lt;li&gt;
                        &lt;Link href={`/`}&gt;Home Page&lt;/Link&gt;
                    &lt;/li&gt;
                    {links.map(({ name, href }) =&gt; {
                        return (
                            &lt;li&gt;
                                &lt;Link href={`${href}`}&gt;{name}&lt;/Link&gt;
                            &lt;/li&gt;
                        );
                    })}
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/nav&gt;
    );
};

export default Navbar;
</code></pre>
<p>app/layout</p>
<pre><code class="language-js">import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';
import Navbar from '@/components/Navbar';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
    title: 'Create Next App',
    description: 'Generated by create next app'
};

export default function RootLayout({
    children
}: Readonly&lt;{
    children: React.ReactNode;
}&gt;) {
    return (
        &lt;html lang="en"&gt;
            &lt;body className={inter.className}&gt;
                &lt;Navbar /&gt;
                &lt;main className="px-8 py-20 max-w-6xl mx-auto"&gt;{children}&lt;/main&gt;
            &lt;/body&gt;
        &lt;/html&gt;
    );
}
</code></pre>
<h2 id="server-components-vs-client-components"><a class="header" href="#server-components-vs-client-components">Server Components VS Client Components</a></h2>
<ul>
<li>
<p><a href="https://nextjs.org/docs/app/building-your-application/rendering/server-components">Server Components</a></p>
</li>
<li>
<p><a href="https://nextjs.org/docs/app/building-your-application/rendering/client-components">Client Components</a></p>
</li>
<li>
<p>BY DEFAULT, NEXT.JS USES SERVER COMPONENTS !!!!</p>
</li>
<li>
<p>To use Client Components, you can add the React "use client" directive</p>
</li>
</ul>
<h3 id="server-components"><a class="header" href="#server-components">Server Components</a></h3>
<p>Benefits :</p>
<ul>
<li>data fetching</li>
<li>security</li>
<li>caching</li>
<li>bundle size</li>
</ul>
<p>Data Fetching: Server Components allow you to move data fetching to the server, closer to your data source. This can improve performance by reducing time it takes to fetch data needed for rendering, and the amount of requests the client needs to make.
Security: Server Components allow you to keep sensitive data and logic on the server, such as tokens and API keys, without the risk of exposing them to the client.
Caching: By rendering on the server, the result can be cached and reused on subsequent requests and across users. This can improve performance and reduce cost by reducing the amount of rendering and data fetching done on each request.
Bundle Sizes: Server Components allow you to keep large dependencies that previously would impact the client JavaScript bundle size on the server. This is beneficial for users with slower internet or less powerful devices, as the client does not have to download, parse and execute any JavaScript for Server Components.
Initial Page Load and First Contentful Paint (FCP): On the server, we can generate HTML to allow users to view the page immediately, without waiting for the client to download, parse and execute the JavaScript needed to render the page.
Search Engine Optimization and Social Network Shareability: The rendered HTML can be used by search engine bots to index your pages and social network bots to generate social card previews for your pages.
Streaming: Server Components allow you to split the rendering work into chunks and stream them to the client as they become ready. This allows the user to see parts of the page earlier without having to wait for the entire page to be rendered on the server.</p>
<h3 id="client-components"><a class="header" href="#client-components">Client Components</a></h3>
<p>Benefits :</p>
<ul>
<li>Interactivity: Client Components can use state, effects, and event listeners, meaning they can provide immediate feedback to the user and update the UI.</li>
<li>Browser APIs: Client Components have access to browser APIs, like geolocation or localStorage, allowing you to build UI for specific use cases.</li>
</ul>
<h2 id="challenge---setup-counter"><a class="header" href="#challenge---setup-counter">Challenge - Setup Counter</a></h2>
<ul>
<li>setup our home page (no restrictions)</li>
<li>setup a simple counter in app/client/page.js</li>
</ul>
<h3 id="counter--client-component"><a class="header" href="#counter--client-component">Counter ( Client Component)</a></h3>
<pre><code class="language-js">import React, { useState } from 'react';

const ClientPage = () =&gt; {
    const [count, setCount] = useState(0);
    return (
        &lt;div&gt;
            &lt;h3&gt;ClientPage&lt;/h3&gt;
            &lt;button
                type="button"
                onClick={() =&gt; {
                    setCount((c) =&gt; c + 1);
                }}
            &gt;
                {count}
            &lt;/button&gt;
        &lt;/div&gt;
    );
};

export default ClientPage;
</code></pre>
<h2 id="challenge---fetch-data-in-drinks-page"><a class="header" href="#challenge---fetch-data-in-drinks-page">Challenge - Fetch Data in Drinks Page</a></h2>
<ul>
<li>setup logic</li>
<li>visit the page</li>
<li>look for log in the terminal 😀</li>
</ul>
<p>app/drinks/page.js</p>
<pre><code class="language-js">const url = 'https://www.thecocktaildb.com/api/json/v1/1/search.php?f=a';

const DrinksPage = async () =&gt; {
    const response = await fetch(url);
    const data = await response.json();
    console.log(data);
    return (
        &lt;div&gt;
            &lt;h1 className="text-7xl"&gt;DrinksPage&lt;/h1&gt;
        &lt;/div&gt;
    );
};
export default DrinksPage;
</code></pre>
<h2 id="loading-component"><a class="header" href="#loading-component">Loading Component</a></h2>
<p>The special file loading.js helps you create meaningful Loading UI with React Suspense. With this convention, you can show an instant loading state from the server while the content of a route segment loads. The new content is automatically swapped in once rendering is complete.</p>
<ul>
<li>drinks/loading.js</li>
</ul>
<pre><code class="language-js">const loading = () =&gt; {
    return &lt;span className="loading"&gt;&lt;/span&gt;;
};
export default loading;
</code></pre>
<ul>
<li>refactor drinks page</li>
</ul>
<pre><code class="language-js">import React from 'react';

const url = 'https://www.thecocktaildb.com/api/json/v1/1/search.php?f=a';
const fetchData = async () =&gt; {
    await new Promise((res, _) =&gt; {
        setTimeout(() =&gt; {
            res('Done!');
        }, 1000);
    });
    const resp = await fetch(url);
    // throw error
    if (!resp.ok) {
        throw new Error('Failed to fetch drinks...');
    }
    const data = await resp.json();
    return data;
};

const DrinksPage = async () =&gt; {
    const data = await fetchData();
    console.log(data);

    return &lt;div&gt;DrinksPage&lt;/div&gt;;
};

export default DrinksPage;
</code></pre>
<h2 id="error-component"><a class="header" href="#error-component">Error Component</a></h2>
<p>The error.js file convention allows you to gracefully handle unexpected runtime errors in nested routes.</p>
<ul>
<li>drinks/error.js</li>
<li>'use client'</li>
</ul>
<pre><code class="language-js">'use client';
const error = (err: any) =&gt; {
    return &lt;div&gt;there was an error... {err.error.message}&lt;/div&gt;;
};
export default error;
</code></pre>
<h2 id="nested-layouts"><a class="header" href="#nested-layouts">Nested Layouts</a></h2>
<ul>
<li>
<p>create app/drinks/layout.js</p>
</li>
<li>
<p>UI will be applied to app/drinks - segment</p>
</li>
<li>
<p>don't forget about the "children"</p>
</li>
<li>
<p>we can fetch data in the layout but...
at the moment can't pass data down to children (pages) 😞</p>
<p>layout.js</p>
</li>
</ul>
<pre><code class="language-js">export default function DrinksLayout({ children }) {
    return (
        &lt;div className="max-w-xl "&gt;
            &lt;div className="mockup-code mb-8"&gt;
                &lt;pre data-prefix="$"&gt;
                    &lt;code&gt;npx create-next-app@latest nextjs-tutorial&lt;/code&gt;
                &lt;/pre&gt;
            &lt;/div&gt;
            {children}
        &lt;/div&gt;
    );
}
</code></pre>
<h2 id="dynamic-routes-1"><a class="header" href="#dynamic-routes-1">Dynamic Routes</a></h2>
<ul>
<li>app/drinks/[id]/page.js</li>
</ul>
<pre><code class="language-js">const page = ({ params }) =&gt; {
    console.log(params);

    return (
        &lt;div&gt;
            &lt;h1 className="text-7xl"&gt;{params.id}&lt;/h1&gt;
        &lt;/div&gt;
    );
};
export default page;
</code></pre>
<h2 id="challenge---drinks-list"><a class="header" href="#challenge---drinks-list">Challenge - Drinks List</a></h2>
<ul>
<li>render a list of drinks</li>
<li>each item is a link to a drink[id] page</li>
</ul>
<h2 id="drinks-list"><a class="header" href="#drinks-list">Drinks List</a></h2>
<ul>
<li>create components/DrinksList.jsx</li>
<li>render in drinks/page and pass the drinks down</li>
<li>iterate over the drinks and return links</li>
</ul>
<p>DrinksList.jsx</p>
<pre><code class="language-js">import Link from 'next/link';

const DrinksList = ({ drinks }) =&gt; {
    return (
        &lt;ul className="menu menu-vertical pl-0"&gt;
            {drinks.map((drink) =&gt; (
                &lt;li key={drink.idDrink}&gt;
                    &lt;Link
                        href={`/drinks/${drink.idDrink}`}
                        className="text-xl font-medium"
                    &gt;
                        {drink.strDrink}
                    &lt;/Link&gt;
                &lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
};
export default DrinksList;
</code></pre>
<p>app/drinks/page.js</p>
<pre><code class="language-js">const url = 'https://www.thecocktaildb.com/api/json/v1/1/search.php?f=a';
import DrinksList from '@/components/DrinksList';
const fetchDrinks = async () =&gt; {
    // just for demo purposes
    await new Promise((resolve) =&gt; setTimeout(resolve, 1000));
    const response = await fetch(url);

    if (!response.ok) {
        throw new Error('Failed to fetch drinks...');
    }
    const data = await response.json();
    return data;
};

const DrinksPage = async () =&gt; {
    const data = await fetchDrinks();

    return (
        &lt;div&gt;
            &lt;DrinksList drinks={data.drinks} /&gt;
        &lt;/div&gt;
    );
};
export default DrinksPage;
</code></pre>
<h2 id="challenge---render-single-drink"><a class="header" href="#challenge---render-single-drink">Challenge - Render Single Drink</a></h2>
<ul>
<li>in drinks/[id], fetch and render drink title</li>
<li>hint:params object</li>
</ul>
<pre><code class="language-js">const url = 'https://www.thecocktaildb.com/api/json/v1/1/lookup.php?i=';
</code></pre>
<h2 id="render-single-drink"><a class="header" href="#render-single-drink">Render Single Drink</a></h2>
<p>drinks/[id]/page.js</p>
<pre><code class="language-js">import Link from 'next/link';
const url = 'https://www.thecocktaildb.com/api/json/v1/1/lookup.php?i=';

const getSingleDrink = async (id) =&gt; {
    const res = await fetch(`${url}${id}`);

    if (!res.ok) {
        throw new Error('Failed to fetch drink...');
    }
    return res.json();
};

const SingleDrink = async ({ params }) =&gt; {
    const data = await getSingleDrink(params.id);
    const title = data?.drinks[0]?.strDrink;
    const imgSrc = data?.drinks[0]?.strDrinkThumb;
    return (
        &lt;div&gt;
            &lt;Link href="/drinks" className="btn btn-primary mt-8 mb-12"&gt;
                back to drinks
            &lt;/Link&gt;
            &lt;h1 className="text-4xl mb-8"&gt;{title}&lt;/h1&gt;
        &lt;/div&gt;
    );
};
export default SingleDrink;
</code></pre>
<h2 id="next-image-component"><a class="header" href="#next-image-component">Next Image Component</a></h2>
<ul>
<li>get random image from pexels site
<a href="https://www.pexels.com/photo/red-glass-with-garnished-beverage-2842876/">Random Drink</a></li>
</ul>
<p>The Next.js Image component extends the HTML <img> element with features for automatic image optimization:</p>
<ul>
<li>Size Optimization: Automatically serve correctly sized images for each device, using modern image formats like WebP and AVIF.</li>
<li>Visual Stability: Prevent layout shift automatically when images are loading.</li>
<li>Faster Page Loads: Images are only loaded when they enter the viewport using native browser lazy loading, with optional blur-up placeholders.</li>
<li>Asset Flexibility: On-demand image resizing, even for images stored on remote servers</li>
</ul>
<p>drinks[id]/page.js</p>
<pre><code class="language-js">import Link from 'next/link';
const url = 'https://www.thecocktaildb.com/api/json/v1/1/lookup.php?i=';

import drinkImg from './drink.jpg';
import Image from 'next/image';

const SingleDrink = async ({ params }) =&gt; {
    const data = await getSingleDrink(params.id);
    const title = data?.drinks[0]?.strDrink;
    const imgSrc = data?.drinks[0]?.strDrinkThumb;
    return (
        &lt;div&gt;
            &lt;Link href="/drinks" className="btn btn-primary mt-8 mb-12"&gt;
                back to drinks
            &lt;/Link&gt;
            {/* &lt;img src={imgSrc} alt='' /&gt; */}
            &lt;Image src={drinkImg} className="w-48 h-48 rounded" alt="" /&gt;
            &lt;h1 className="text-4xl mb-8"&gt;{title}&lt;/h1&gt;
        &lt;/div&gt;
    );
};
export default SingleDrink;
</code></pre>
<h2 id="remote-images"><a class="header" href="#remote-images">Remote Images</a></h2>
<ul>
<li>
<p>To use a remote image, the src property should be a URL string.</p>
</li>
<li>
<p>Since Next.js does not have access to remote files during the build process, you'll need to provide the width, height and optional blurDataURL props manually.</p>
</li>
<li>
<p>The width and height attributes are used to infer the correct aspect ratio of image and avoid layout shift from the image loading in. The width and height do not determine the rendered size of the image file.</p>
</li>
<li>
<p>To safely allow optimizing images, define a list of supported URL patterns in next.config.js. Be as specific as possible to prevent malicious usage.</p>
</li>
<li>
<p>restart dev server</p>
</li>
<li>
<p>priority property to prioritize the image for loading</p>
</li>
</ul>
<pre><code class="language-js">const SingleDrink = async ({ params }) =&gt; {
    const data = await getSingleDrink(params.id);
    const title = data?.drinks[0]?.strDrink;
    const imgSrc = data?.drinks[0]?.strDrinkThumb;
    return (
        &lt;div&gt;
            &lt;Link href="/drinks" className="btn btn-primary mt-8 mb-12"&gt;
                back to drinks
            &lt;/Link&gt;
            {/* &lt;img src={imgSrc} alt='' /&gt; */}
            {/* &lt;Image src={drinkImg} className='w-48 h-48 rounded' alt='' /&gt; */}
            &lt;Image
                src={imgSrc}
                width={300}
                height={300}
                className="w-48 h-48 rounded shadow-lg mb-4"
                priority
                alt=""
            /&gt;
            &lt;h1 className="text-4xl mb-8"&gt;{title}&lt;/h1&gt;
        &lt;/div&gt;
    );
};
export default SingleDrink;
</code></pre>
<pre><code class="language-js">** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'www.thecocktaildb.com',
        port: '',
        pathname: '/images/**',
      },
    ],
  },
};

module.exports = nextConfig;
</code></pre>
<h2 id="remote-images---responsive"><a class="header" href="#remote-images---responsive">Remote Images - Responsive</a></h2>
<ul>
<li>
<p>The fill prop allows your image to be sized by its parent element</p>
</li>
<li>
<p>sizes property helps the browser select the most appropriate image size to load based on the user's device and screen size, improving website performance and user experience.</p>
<p>DrinksList.jsx</p>
</li>
</ul>
<pre><code class="language-js">import Image from 'next/image';
import Link from 'next/link';

const DrinksList = ({ drinks }) =&gt; {
    return (
        &lt;ul className="grid sm:grid-cols-2 gap-6 mt-6"&gt;
            {drinks.map((drink) =&gt; (
                &lt;li key={drink.idDrink}&gt;
                    &lt;Link
                        href={`/drinks/${drink.idDrink}`}
                        className="text-xl font-medium"
                    &gt;
                        &lt;div className="relative h-48 mb-4"&gt;
                            &lt;Image
                                src={drink.strDrinkThumb}
                                fill
                                sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw"
                                alt={drink.strDrink}
                                className="rounded-md object-cover"
                            /&gt;
                        &lt;/div&gt;
                        {drink.strDrink}
                    &lt;/Link&gt;
                &lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
};
export default DrinksList;
</code></pre>
<h2 id="more-routing"><a class="header" href="#more-routing">More Routing</a></h2>
<ul>
<li>
<p>Private Folders
_folder</p>
</li>
<li>
<p>Route Groups
(dashboard)</p>
</li>
<li>
<p>Dynamic Routes</p>
<ul>
<li>[...folder] - Catch-all route segment</li>
<li>[[...folder]] Optional catch-all route segment (used by Clerk)</li>
</ul>
</li>
<li>
<p>create test folder app/_css</p>
</li>
<li>
<p>create app/(dashboard)/auth</p>
<ul>
<li>the url is just '/auth'</li>
</ul>
</li>
<li>
<p>create app/(dashboard)/auth/[sign-in]</p>
</li>
</ul>
<pre><code class="language-js">const SignInPage = ({ params }) =&gt; {
    console.log(params);
    return &lt;div&gt;SignInPage&lt;/div&gt;;
};
export default SignInPage;
</code></pre>
<ul>
<li>create app/(dashboard)/auth/[...sign-in]</li>
<li>create app/(dashboard)/auth/[[...sign-in]]</li>
</ul>
<h2 id="prisma"><a class="header" href="#prisma">Prisma</a></h2>
<ul>
<li>install prisma vs-code extension</li>
</ul>
<p><a href="https://www.prisma.io/docs/concepts/database-connectors/sqlite">Prisma sqlite</a></p>
<p>Prisma ORM is a database toolkit that simplifies database access in web applications. It allows developers to interact with databases using a type-safe and auto-generated API, making database operations easier and more secure.</p>
<ul>
<li>Prisma server: A standalone infrastructure component sitting on top of your database.</li>
<li>Prisma client: An auto-generated library that connects to the Prisma server and lets you read, write and stream data in your database. It is used for data access in your applications.</li>
</ul>
<pre><code class="language-sh">npm install prisma --save-dev
npm install @prisma/client
</code></pre>
<pre><code class="language-sh">npx prisma init
</code></pre>
<p>This creates a new prisma directory with your Prisma schema file and configures SQLite as your database. You're now ready to model your data and create your database with some tables.</p>
<pre><code class="language-prisma">generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}
</code></pre>
<ul>
<li>ADD .ENV TO .GITIGNORE !!!!</li>
</ul>
<p>.env</p>
<pre><code class="language-js">DATABASE_URL = 'file:./dev.db';
</code></pre>
<h2 id="setup-instance"><a class="header" href="#setup-instance">Setup Instance</a></h2>
<p>In development, the command next dev clears Node.js cache on run. This in turn initializes a new PrismaClient instance each time due to hot reloading that creates a connection to the database. This can quickly exhaust the database connections as each PrismaClient instance holds its own connection pool.</p>
<p>(Prisma Instance)[https://www.prisma.io/docs/guides/other/troubleshooting-orm/help-articles/nextjs-prisma-client-dev-practices#solution]</p>
<ul>
<li>create utils/db.ts</li>
</ul>
<pre><code class="language-js">import { PrismaClient } from '@prisma/client';

const prismaClientSingleton = () =&gt; {
  return new PrismaClient();
};

type PrismaClientSingleton = ReturnType&lt;typeof prismaClientSingleton&gt;;

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClientSingleton | undefined;
};

const prisma = globalForPrisma.prisma ?? prismaClientSingleton();

export default prisma;

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
</code></pre>
<h2 id="create-model"><a class="header" href="#create-model">Create Model</a></h2>
<pre><code class="language-prisma">model Task {
  id String @id @default(uuid())
  content String
  createdAt DateTime @default(now())
  completed Boolean @default(false)
}
</code></pre>
<ul>
<li>safely applies and tracks changes to the database structure.</li>
</ul>
<pre><code class="language-sh">npx prisma migrate dev
</code></pre>
<h3 id="prisma-model"><a class="header" href="#prisma-model">Prisma Model</a></h3>
<p>The Prisma model provided is a representation of a Task entity in the context of a database schema. Here's a detailed description of each component within this model:</p>
<p>model Task { ... }: This is the definition of the Task model. In Prisma, a model represents a table in the database. It serves as a blueprint for the records that will be stored in the corresponding table, defining the structure and behavior of the data.</p>
<p>id String @id @default(uuid()): This line defines a field named id of type String which is marked with @id, signifying that this field is the primary key of the model. The @default(uuid()) directive indicates that the default value for this field will be a UUID (Universally Unique Identifier) generated by Prisma.</p>
<p>content String: This line declares a field named content of type String. This field will store textual data, presumably the details or description of the task.</p>
<p>createdAt DateTime @default(now()): This field is named createdAt and is of type DateTime. It has a default value set to the current timestamp at the time of record creation, indicated by the @default(now()) directive.</p>
<p>completed Boolean @default(false): Lastly, the completed field is of type Boolean and is used to indicate whether the task has been completed. It defaults to false, meaning when a new task record is created, it is considered incomplete by default.</p>
<p>In Prisma, the term "model" refers to an abstraction that maps to a table in your database. Prisma models are defined in the Prisma schema, which is a declarative representation of your database's structure. Each model in the Prisma schema corresponds to a table in the database, and each field within a model corresponds to a column in that table. This schema plays a central role in Prisma's features, such as type-safe database access and migrations.</p>
<h2 id="prisma-example"><a class="header" href="#prisma-example">Prisma Example</a></h2>
<ul>
<li>remove query</li>
<li>fix the links the navbar</li>
</ul>
<pre><code class="language-js">import prisma from '@/utils/db';

const prismaHandlers = async () =&gt; {
    await prisma.task.create({
        data: {
            content: 'wake up'
        }
    });
    const allTasks = await prisma.task.findMany({
        orderBy: {
            createdAt: 'desc'
        }
    });

    return allTasks;
};

const Prisma = async () =&gt; {
    const tasks = await prismaHandlers();
    return (
        &lt;div&gt;
            &lt;h1 className="text-3xl font-medium mb-4"&gt;Prisma Example &lt;/h1&gt;
            {tasks.map((task) =&gt; {
                return (
                    &lt;h2 key={task.id} className="text-xl py-2"&gt;
                        😬 {task.content}
                    &lt;/h2&gt;
                );
            })}
        &lt;/div&gt;
    );
};
export default Prisma;
</code></pre>
<h2 id="optional---prisma-crud"><a class="header" href="#optional---prisma-crud">Optional - Prisma Crud</a></h2>
<p><a href="https://www.prisma.io/docs/concepts/components/prisma-client/crud">Prisma Docs</a></p>
<ul>
<li>Create Single Record</li>
</ul>
<pre><code class="language-js">const task = await prisma.task.create({
    data: {
        content: 'some task'
    }
});
</code></pre>
<ul>
<li>Get All Records</li>
</ul>
<pre><code class="language-js">const tasks = await prisma.task.findMany();
</code></pre>
<ul>
<li>Get record by ID or unique identifier</li>
</ul>
<pre><code class="language-js">// By unique identifier
const user = await prisma.user.findUnique({
    where: {
        email: 'elsa@prisma.io'
    }
});

// By ID
const task = await prisma.task.findUnique({
    where: {
        id: id
    }
});
</code></pre>
<ul>
<li>Update Record</li>
</ul>
<pre><code class="language-js">const updateTask = await prisma.task.update({
    where: {
        id: id
    },
    data: {
        content: 'updated task'
    }
});
</code></pre>
<ul>
<li>Update or create records</li>
</ul>
<pre><code class="language-js">const upsertTask = await prisma.task.upsert({
    where: {
        id: id
    },
    update: {
        content: 'some value'
    },
    create: {
        content: 'some value'
    }
});
</code></pre>
<ul>
<li>Delete a single record</li>
</ul>
<pre><code class="language-js">const deleteTask = await prisma.task.delete({
    where: {
        id: id
    }
});
</code></pre>
<h2 id="challenge---display-tasks"><a class="header" href="#challenge---display-tasks">Challenge - Display Tasks</a></h2>
<ul>
<li>create TaskForm, TaskList, DeleteForm components</li>
<li>render them in tasks page</li>
<li>in TaskList render all tasks</li>
<li>also display editBtn and DeleteForm</li>
<li>editBtn - link to single task page</li>
<li>reference the complete project</li>
</ul>
<p>tasks/page.js</p>
<pre><code class="language-js">import TaskForm from '@/components/TaskForm';
import TaskList from '@/components/TaskList';

const TasksPage = () =&gt; {
    return (
        &lt;div className="max-w-lg"&gt;
            &lt;TaskForm /&gt;
            &lt;TaskList /&gt;
        &lt;/div&gt;
    );
};
export default TasksPage;
</code></pre>
<p>components/TaskList</p>
<pre><code class="language-js">import prisma from '@/utils/db';
import Link from 'next/link';
import DeleteForm from './DeleteForm';

const TaskList = async () =&gt; {
    const tasks = await prisma.task.findMany({
        orderBy: {
            createdAt: 'desc'
        }
    });
    if (tasks.length === 0)
        return &lt;h2 className="mt-8 font-medium text-lg"&gt;No tasks to show&lt;/h2&gt;;
    return (
        &lt;ul className="mt-8"&gt;
            {tasks.map((task) =&gt; (
                &lt;li
                    key={task.id}
                    className="flex justify-between items-center px-6 py-4 mb-4 border border-base-300 rounded-lg shadow-lg"
                &gt;
                    &lt;h2
                        className={`text-lg capitalize ${
                            task.completed ? 'line-through' : null
                        }`}
                    &gt;
                        {task.content}
                    &lt;/h2&gt;
                    &lt;div className="flex gap-6 items-center"&gt;
                        &lt;Link
                            href={`/tasks/${task.id}`}
                            className="btn btn-accent btn-xs"
                        &gt;
                            edit
                        &lt;/Link&gt;
                        &lt;DeleteForm id={task.id} /&gt;
                    &lt;/div&gt;
                &lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
};
export default TaskList;
</code></pre>
<h2 id="server-actions"><a class="header" href="#server-actions">Server Actions</a></h2>
<ul>
<li>
<p>asynchronous server functions that can be called directly from your components.</p>
</li>
<li>
<p>typical setup for server state mutations (create, update, delete)</p>
<ul>
<li>endpoint on the server (api route on Next.js)</li>
<li>make request from the front-end
<ul>
<li>setup form, handle submission etc</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Next.js server actions allow you to mutate server state directly from within a React component by defining server-side logic alongside client-side interactions.</p>
</li>
</ul>
<p>Rules :</p>
<ul>
<li>must be async</li>
<li>add 'use server' in function body
<ul>
<li>use only in React Server Component</li>
</ul>
</li>
</ul>
<pre><code class="language-js">export default function ServerComponent() {
    async function myAction(formData) {
        'use server';
        // access input values with formData
        // formData.get('name')
        // mutate data (server)
        // revalidate cache
    }

    return &lt;form action={myAction}&gt;...&lt;/form&gt;;
}
</code></pre>
<ul>
<li>or setup in a separate file ('use server' at the top)
<ul>
<li>can use in both (RSC and RCC)</li>
</ul>
</li>
</ul>
<p>utils/actions.js</p>
<pre><code class="language-js">'use server';

export async function myAction() {
    // ...
}
</code></pre>
<pre><code class="language-js">'use client';

import { myAction } from './actions';

export default function ClientComponent() {
    return (
        &lt;form action={myAction}&gt;
            &lt;button type="submit"&gt;Add to Cart&lt;/button&gt;
        &lt;/form&gt;
    );
}
</code></pre>
<h2 id="taskform"><a class="header" href="#taskform">TaskForm</a></h2>
<pre><code class="language-js">import prisma from '@/utils/db';
import { revalidatePath } from 'next/cache';

const createTask = async (formData) =&gt; {
    'use server';
    const content = formData.get('content');
    // some validation here

    await prisma.task.create({
        data: {
            content
        }
    });
    // revalidate path
    revalidatePath('/tasks');
};

const TaskForm = () =&gt; {
    return (
        &lt;form action={createTask}&gt;
            &lt;div className="join w-full"&gt;
                &lt;input
                    className="input input-bordered join-item w-full"
                    placeholder="Type Here"
                    type="text"
                    name="content"
                    required
                /&gt;
                &lt;button type="submit" className="btn join-item btn-primary"&gt;
                    create task
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/form&gt;
    );
};
export default TaskForm;
</code></pre>
<h2 id="refactor"><a class="header" href="#refactor">Refactor</a></h2>
<ul>
<li>create utils/actions</li>
<li>move get all tasks and create task functionality</li>
<li>refactor TaskForm and TaskList</li>
</ul>
<pre><code class="language-js">'use server';

import prisma from '@/utils/db';
import { revalidatePath } from 'next/cache';

export const getAllTasks = async () =&gt; {
    return prisma.task.findMany({
        orderBy: {
            createdAt: 'desc'
        }
    });
};

export const createTask = async (formData) =&gt; {
    const content = formData.get('content');
    // some validation here

    await prisma.task.create({
        data: {
            content
        }
    });
    // revalidate path
    revalidatePath('/tasks');
};
</code></pre>
<h2 id="deleteform"><a class="header" href="#deleteform">DeleteForm</a></h2>
<ul>
<li>will use "action" approach since it works without JS</li>
<li>invoke by using startTransition (useTransition hook)</li>
</ul>
<pre><code class="language-js">import { deleteTask } from '@/utils/actions';

const DeleteForm = ({ id }) =&gt; {
    return (
        &lt;form action={deleteTask}&gt;
            &lt;input type="hidden" name="id" value={id} /&gt;
            &lt;button className="btn btn-error btn-xs"&gt;delete&lt;/button&gt;
        &lt;/form&gt;
    );
};
export default DeleteForm;
</code></pre>
<p>utils/actions</p>
<pre><code class="language-js">export const deleteTask = async (formData) =&gt; {
    const id = formData.get('id');
    await prisma.task.delete({ where: { id } });
    revalidatePath('/tasks');
};
</code></pre>
<h2 id="challenge---edit-task"><a class="header" href="#challenge---edit-task">Challenge - Edit Task</a></h2>
<ul>
<li>create single task page</li>
<li>get task info (hint:params)</li>
<li>create EditForm component</li>
<li>setup form with all the inputs</li>
<li>render in single task page</li>
<li>create server action to update task</li>
<li>extra - redirect when complete</li>
</ul>
<h2 id="edit-task"><a class="header" href="#edit-task">Edit Task</a></h2>
<p>tasks/[id]/page.js</p>
<pre><code class="language-js">import EditForm from '@/components/EditForm';
import { getTask } from '@/utils/actions';
import Link from 'next/link';
const TaskPage = async ({ params }) =&gt; {
    const task = await getTask(params.id);

    return (
        &lt;&gt;
            &lt;div className="mb-16"&gt;
                &lt;Link href="/tasks" className="btn btn-accent"&gt;
                    Back to Tasks
                &lt;/Link&gt;
            &lt;/div&gt;
            &lt;EditForm task={task} /&gt;
        &lt;/&gt;
    );
};
export default TaskPage;
</code></pre>
<p>actions</p>
<pre><code class="language-js">export const getTask = async (id) =&gt; {
    return prisma.task.findUnique({
        where: {
            id
        }
    });
};

export const editTask = async (formData) =&gt; {
    const id = formData.get('id');
    const content = formData.get('content');
    const completed = formData.get('completed');

    await prisma.task.update({
        where: {
            id: id
        },
        data: {
            content: content,
            completed: completed === 'on' ? true : false
        }
    });
    // redirect won't works unless the component has 'use client'
    // another option, setup the editTask in the component directly
    redirect('/tasks');
};
</code></pre>
<p>EditForm.js</p>
<pre><code class="language-js">'use client';
import { editTask } from '@/utils/actions';

const EditForm = ({ task }) =&gt; {
    const { id, completed, content } = task;
    return (
        &lt;form
            action={editTask}
            className="max-w-sm bg-base-100 p-12 border border-base-300  rounded-lg"
        &gt;
            &lt;input type="hidden" name="id" value={id} /&gt;
            {/* content */}

            &lt;input
                type="text"
                required
                defaultValue={content}
                name="content"
                className="input input-bordered w-full"
            /&gt;

            {/* completed */}
            &lt;div className="form-control my-4"&gt;
                &lt;label className="label cursor-pointer"&gt;
                    &lt;span className="label-text"&gt;Completed&lt;/span&gt;
                    &lt;input
                        type="checkbox"
                        defaultChecked={completed}
                        name="completed"
                        className="checkbox checkbox-primary checkbox-sm"
                    /&gt;
                &lt;/label&gt;
            &lt;/div&gt;
            &lt;button className="btn btn-primary btn-block btn-sm"&gt;edit&lt;/button&gt;
        &lt;/form&gt;
    );
};
export default EditForm;
</code></pre>
<h2 id="server-actions---loading-state-response-errors"><a class="header" href="#server-actions---loading-state-response-errors">Server Actions - Loading State, Response, Errors</a></h2>
<ul>
<li>clone TaskForm - copy and rename TaskFormCustom</li>
<li>make it client component</li>
<li>import and replace in Tasks page</li>
<li>clone createTask in actions - copy and rename createTaskCustom</li>
<li>import and replace in TaskFormCustom component</li>
</ul>
<h2 id="server-actions---loading-state"><a class="header" href="#server-actions---loading-state">Server Actions - Loading State</a></h2>
<p>TaskFormCustom</p>
<pre><code class="language-js">'use client';

import { createTaskCustom } from '@/utils/actions';
import { useFormStatus } from 'react-dom';
// The useFormStatus Hook provides status information of the last form submission.
// useFormState is a Hook that allows you to update state based on the result of a form action.

const SubmitButton = () =&gt; {
    const { pending } = useFormStatus();

    return (
        &lt;button
            type="submit"
            className="btn join-item btn-primary"
            disabled={pending}
        &gt;
            {pending ? 'please wait... ' : 'create task'}
        &lt;/button&gt;
    );
};

const TaskForm = () =&gt; {
    return (
        &lt;form action={createTaskCustom}&gt;
            &lt;div className="join w-full"&gt;
                &lt;input
                    className="input input-bordered join-item w-full"
                    placeholder="Type Here"
                    type="text"
                    name="content"
                    required
                /&gt;
                &lt;SubmitButton /&gt;
            &lt;/div&gt;
        &lt;/form&gt;
    );
};
export default TaskForm;
</code></pre>
<pre><code class="language-js">export const createTaskCustom = async (formData) =&gt; {
    await new Promise((resolve) =&gt; setTimeout(resolve, 2000));
    const content = formData.get('content');
    // some validation here

    await prisma.task.create({
        data: {
            content
        }
    });
    // revalidate path
    revalidatePath('/tasks');
};
</code></pre>
<h2 id="error-handling-and-response-to-user"><a class="header" href="#error-handling-and-response-to-user">Error Handling and Response To User</a></h2>
<p>TaskFormCustom.jsx</p>
<pre><code class="language-js">'use client';

import { createTaskCustom } from '@/utils/actions';
import { useFormStatus, useFormState } from 'react-dom';
// The useFormStatus Hook provides status information of the last form submission.
// useFormState is a Hook that allows you to update state based on the result of a form action.

const SubmitButton = () =&gt; {
    const { pending } = useFormStatus();

    return (
        &lt;button
            type="submit"
            className="btn join-item btn-primary"
            disabled={pending}
        &gt;
            {pending ? 'please wait... ' : 'create task'}
        &lt;/button&gt;
    );
};

const initialState = {
    message: null
};

const TaskForm = () =&gt; {
    const [state, formAction] = useFormState(createTaskCustom, initialState);

    return (
        &lt;form action={formAction}&gt;
            {state.message ? &lt;p className="mb-2"&gt;{state.message}&lt;/p&gt; : null}
            &lt;div className="join w-full"&gt;
                &lt;input
                    className="input input-bordered join-item w-full"
                    placeholder="Type Here"
                    type="text"
                    name="content"
                    required
                /&gt;
                &lt;SubmitButton /&gt;
            &lt;/div&gt;
        &lt;/form&gt;
    );
};
export default TaskForm;
</code></pre>
<p>actions.js</p>
<pre><code class="language-js">// fix params
export const createTaskCustom = async (prevState, formData) =&gt; {
    await new Promise((resolve) =&gt; setTimeout(resolve, 2000));
    const content = formData.get('content');
    // some validation here
    try {
        await prisma.task.create({
            data: {
                content
            }
        });
        // revalidate path
        revalidatePath('/tasks');
        return { message: 'success!!!' };
    } catch (error) {
        // can't return error
        return { message: 'error...' };
    }
};
</code></pre>
<h2 id="extra---more-user-input-validation-options"><a class="header" href="#extra---more-user-input-validation-options">Extra - More User Input Validation Options</a></h2>
<ul>
<li>required attribute a great start</li>
<li>zod library</li>
</ul>
<p>The Zod library is a TypeScript-first schema declaration and validation library that allows developers to create complex type checks with simple syntax.</p>
<p><a href="https://zod.dev/">Zod</a></p>
<pre><code class="language-sh">npm install zod
</code></pre>
<p>actions.js</p>
<pre><code class="language-js">import { z } from 'zod';

export const createTaskCustom = async (prevState, formData) =&gt; {
    await new Promise((resolve) =&gt; setTimeout(resolve, 2000));
    const content = formData.get('content');

    const Task = z.object({
        content: z.string().min(5)
    });

    // some validation here
    try {
        Task.parse({
            content
        });
        await prisma.task.create({
            data: {
                content
            }
        });
        // revalidate path
        revalidatePath('/tasks');
        return { message: 'success!!!' };
    } catch (error) {
        console.log(error);
        // can't return error
        return { message: 'error...' };
    }
};
</code></pre>
<h2 id="providers"><a class="header" href="#providers">Providers</a></h2>
<p><a href="https://react-hot-toast.com/">Beautiful Toasts</a></p>
<pre><code class="language-sh">npm install react-hot-toast
</code></pre>
<ul>
<li>create providers.js file in app</li>
</ul>
<pre><code class="language-js">'use client';
import { Toaster } from 'react-hot-toast';

const Providers = ({ children }) =&gt; {
    return (
        &lt;&gt;
            &lt;Toaster /&gt;
            {children}
        &lt;/&gt;
    );
};
export default Providers;
</code></pre>
<p>layout.js</p>
<pre><code class="language-js">import Providers from './providers';

export default function RootLayout({ children }) {
    return (
        &lt;html lang="en"&gt;
            &lt;body className={inter.className}&gt;
                &lt;Navbar /&gt;
                &lt;main className="px-8 py-20 max-w-6xl mx-auto"&gt;
                    &lt;Providers&gt;{children}&lt;/Providers&gt;
                &lt;/main&gt;
            &lt;/body&gt;
        &lt;/html&gt;
    );
}
</code></pre>
<ul>
<li>simplify createTaskCustom action</li>
</ul>
<pre><code class="language-js">try {
    return { message: 'success' };
} catch (error) {
    console.log(error);
    return { message: 'error' };
}
</code></pre>
<ul>
<li>add toast</li>
</ul>
<p>TaskFormCustom.jsx</p>
<pre><code class="language-js">'use client';
import { createTaskCustom } from '@/utils/actions';
import { useEffect } from 'react';

import { useFormStatus, useFormState } from 'react-dom';
import toast from 'react-hot-toast';
const SubmitBtn = () =&gt; {
    const { pending } = useFormStatus();
    return (
        &lt;button
            type="submit"
            className="btn btn-primary join-item"
            disabled={pending}
        &gt;
            {pending ? 'please wait...' : 'create task'}
        &lt;/button&gt;
    );
};

const initialState = {
    message: null
};

const TaskForm = () =&gt; {
    const [state, formAction] = useFormState(createTaskCustom, initialState);

    useEffect(() =&gt; {
        if (state.message === 'error') {
            toast.error('there was an error');
            return;
        }
        if (state.message) {
            toast.success('task created....');
        }
    }, [state]);

    return (
        &lt;form action={formAction}&gt;
            &lt;div className="join w-full"&gt;
                &lt;input
                    type="text "
                    className="input input-bordered join-item w-full"
                    placeholder="type here"
                    name="content"
                    required
                /&gt;
                &lt;SubmitBtn /&gt;
            &lt;/div&gt;
        &lt;/form&gt;
    );
};
export default TaskForm;
</code></pre>
<h2 id="challenge---add-functionality"><a class="header" href="#challenge---add-functionality">Challenge - Add Functionality</a></h2>
<p>DeleteForm.jsx</p>
<pre><code class="language-js">'use client';
import { useFormStatus } from 'react-dom';
import { deleteTask } from '@/utils/actions';

const SubmitBtn = () =&gt; {
    const { pending } = useFormStatus();
    return (
        &lt;button
            type="submit"
            className="btn btn-xs btn-error"
            disabled={pending}
        &gt;
            {pending ? 'pending...' : 'delete'}
        &lt;/button&gt;
    );
};

const DeleteForm = ({ id }) =&gt; {
    return (
        &lt;form action={deleteTask}&gt;
            &lt;input type="hidden" name="id" value={id} /&gt;
            &lt;SubmitBtn /&gt;
        &lt;/form&gt;
    );
};
export default DeleteForm;
</code></pre>
<h2 id="route-handlers"><a class="header" href="#route-handlers">Route Handlers</a></h2>
<ul>
<li>install Thunder Client</li>
</ul>
<p>Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs.</p>
<ul>
<li>in app create folder "api"</li>
<li>in there create folder "tasks" with route.js file</li>
</ul>
<p>The following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. If an unsupported method is called, Next.js will return a 405 Method Not Allowed response.</p>
<p>In addition to supporting native Request and Response. Next.js extends them with NextRequest and NextResponse to provide convenient helpers for advanced use cases.</p>
<p>app/api/tasks/route.js</p>
<pre><code class="language-js">// the following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. If an unsupported method is called, Next.js will return a 405 Method Not Allowed response.

import { NextResponse } from 'next/server';
import db from '@/utils/db';

export const GET = async (request) =&gt; {
    const tasks = await db.task.findMany();
    return Response.json({ data: tasks });
    // return NextResponse.json({ data: tasks });
};

export const POST = async (request) =&gt; {
    const data = await request.json();
    const task = await db.task.create({
        data: {
            content: data.content
        }
    });
    return NextResponse.json({ data: task });
};
</code></pre>
<h2 id="middleware"><a class="header" href="#middleware">Middleware</a></h2>
<p><a href="https://nextjs.org/docs/app/building-your-application/routing/middleware">Docs</a></p>
<p>Middleware in Next.js is a piece of code that allows you to perform actions before a request is completed and modify the response accordingly.</p>
<ul>
<li>create middleware.js in the root</li>
<li>by default will be invoked for every route in your project</li>
</ul>
<pre><code class="language-js">export function middleware(request) {
    return Response.json({ msg: 'hello there' });
}

export const config = {
    matcher: '/about'
};
</code></pre>
<pre><code class="language-js">import { NextResponse } from 'next/server';

// This function can be marked `async` if using `await` inside
export function middleware(request) {
    return NextResponse.redirect(new URL('/', request.url));
}

// See "Matching Paths" below to learn more
export const config = {
    matcher: ['/about/:path*', '/tasks/:path*']
};
</code></pre>
<h2 id="planetscale"><a class="header" href="#planetscale">PlanetScale</a></h2>
<p><a href="https://planetscale.com/">Host DB</a></p>
<ul>
<li>set DATABASE_URL in .env</li>
</ul>
<pre><code class="language-prisma">generator client {
  provider = "prisma-client-js"
}
datasource db {
  provider = "mysql"
  url = env("DATABASE_URL")
  relationMode = "prisma"
}
</code></pre>
<pre><code class="language-sh">npx prisma db push
</code></pre>
<h3 id="local-build"><a class="header" href="#local-build">Local Build</a></h3>
<h3 id="setup-app"><a class="header" href="#setup-app">Setup App</a></h3>
<p>package.json</p>
<pre><code class="language-json"> "build": "npx prisma generate &amp;&amp; next build",
</code></pre>
<ul>
<li>prisma-example</li>
</ul>
<pre><code class="language-js">import prisma from '@/utils/db';

const prismaHandlers = async () =&gt; {
    console.log('prisma example');
    // await prisma.task.create({
    //   data: {
    //     content: 'wake up',
    //   },
    // });
    return prisma.task.findMany();
};

const PrismaExample = async () =&gt; {
    const tasks = await prismaHandlers();
    if (tasks.length === 0) {
        return (
            &lt;h2 className="mt-8 font-medium text-lg"&gt;No tasks to show...&lt;/h2&gt;
        );
    }

    return (
        &lt;div&gt;
            &lt;h1 className="text-7xl"&gt;PrismaExample&lt;/h1&gt;
            {tasks.map((task) =&gt; {
                return (
                    &lt;h2 key={task.id} className="text-xl py-2"&gt;
                        😬 {task.content}
                    &lt;/h2&gt;
                );
            })}
        &lt;/div&gt;
    );
};
export default PrismaExample;
</code></pre>
<ul>
<li>clean out the DB</li>
</ul>
<pre><code class="language-sh">npm run build
</code></pre>
<pre><code class="language-sh">npm start
</code></pre>
<h2 id="force-dynamic"><a class="header" href="#force-dynamic">Force Dynamic</a></h2>
<ul>
<li>add loading.js to tasks</li>
</ul>
<p>tasks.js</p>
<pre><code class="language-js">export const dynamic = 'force-dynamic';
</code></pre>
<h2 id="deploy"><a class="header" href="#deploy">Deploy</a></h2>
<p><a href="https://vercel.com/">Vercel</a></p>
<ul>
<li>sign up for account</li>
<li>create github repo</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="backend"><a class="header" href="#backend">Backend</a></h3>
<pre><code class="language-sh">mkdir jwt-backend
cd jwt-backend
npm init -y
npm install express bcrypt jsonwebtoken cors nodemon cookie-parser
npm i @prisma/client express dotenv nodemon
npm install express-validator
</code></pre>
<blockquote>
<p>Add Script</p>
</blockquote>
<pre><code class="language-json">"scripts": {
    "dev": "nodemon index.js"
},
</code></pre>
<h3 id="initialize-prisma-project-1"><a class="header" href="#initialize-prisma-project-1">Initialize Prisma project</a></h3>
<pre><code class="language-sh">npx prisma init
</code></pre>
<h3 id="env-variables-1"><a class="header" href="#env-variables-1">ENV Variables</a></h3>
<pre><code>DATABASE_URL="postgresql://postgres:@localhost:5432/postdb?schema=public"
CHECKPOINT_DISABLE=1
</code></pre>
<blockquote>
<p>Documentation Links</p>
</blockquote>
<ul>
<li>
<p><a href="https://www.prisma.io/docs/orm/reference/prisma-cli-reference">cli Reference</a></p>
</li>
<li>
<p><a href="https://www.prisma.io/docs/orm/reference/prisma-client-reference">client Reference</a></p>
</li>
</ul>
<h2 id="modelschema-1"><a class="header" href="#modelschema-1">Model/Schema</a></h2>
<blockquote>
<p>prisma/schema.prisma</p>
</blockquote>
<pre><code class="language-prisma">generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User{
    id Int @id @default(autoincrement())
    email String
    password String
}

</code></pre>
<blockquote>
<p>Run migration</p>
</blockquote>
<pre><code class="language-sh">npx prisma migrate dev --name init
</code></pre>
<blockquote>
<p>Code</p>
</blockquote>
<pre><code class="language-js">// Imports
const express = require('express');
const cookieParser = require('cookie-parser');
const bcrypt = require('bcrypt');
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();
const { body, validationResult } = require('express-validator');
const jwt = require('jsonwebtoken');
const cors = require('cors');
const app = express();

// Constants
const PORT = 3333;
const secret = 'your-secret-key';

// Middlewares

// Verify Token
function verifyToken(req, res, next) {
    const token = req.header('Authorization');
    if (!token) return res.status(401).json({ error: 'Access denied' });
    try {
        const decoded = jwt.verify(token, secret);
        req.userId = decoded.userId;
        next();
    } catch (error) {
        res.status(401).json({ error: 'Invalid token' });
    }
}

// Custom Middleware
const logger = (req, res, next) =&gt; {
    console.log(req.url);
    next();
};

// Validator
const validate = (validations) =&gt; {
    return async (req, res, next) =&gt; {
        for (let validation of validations) {
            const result = await validation.run(req);
            if (result.errors.length) break;
        }

        const errors = validationResult(req);
        if (errors.isEmpty()) {
            return next();
        }

        let msg =
            errors.errors[0]['path'] == 'email'
                ? 'Invalid email address. Please try again.'
                : 'Password must be longer than 6 characters.';

        res.status(400).json({ data: null, errs: msg });
    };
};

// Use CORS middleware
app.use(
    cors({
        origin: ['http://localhost:5173'],
        methods: ['GET', 'POST', 'PUT', 'DELETE'],
        credentials: true
    })
);
// parse form data
app.use(express.urlencoded({ extended: false }));
// parse json
app.use(express.json());
// custom logger
app.use(logger);
// Cookie
app.use(cookieParser());

// Routes
app.post('/', (req, res) =&gt; {
    return res.status(201).json({ name: 'hello' });
});

// User registration
app.post(
    '/register',
    validate([body('email').isEmail(), body('password').isLength({ min: 6 })]),
    async (req, res) =&gt; {
        const { email, password } = req.body;
        try {
            const hashedPassword = await bcrypt.hash(password, 10);
            await prisma.user.create({
                data: { email, password: hashedPassword }
            });
            return res.status(201).json({
                data: { email, password: hashedPassword },
                errs: null
            });
        } catch (err) {
            return res.status(500).json({ data: null, errs: err });
        }
    }
);

// User login
app.post('/login', async (req, res) =&gt; {
    try {
        const { email, password } = req.body;
        const user = await prisma.user.findUnique({ where: { email } });
        if (!user) {
            return res.status(401).json({ error: 'Invalid email!' });
        }
        const passwordMatch = await bcrypt.compare(password, user.password);
        if (!passwordMatch) {
            return res.status(401).json({ error: 'Invalid password!' });
        }
        const token = jwt.sign({ userId: user.id }, secret, {
            expiresIn: '1h'
        });
        const reftoken = jwt.sign({ userId: user.id }, secret, {
            expiresIn: '1h'
        });

        res.cookie('jwt', reftoken, {
            httpOnly: true,
            sameSite: 'None',
            secure: true,
            maxAge: 24 * 60 * 60 * 1000
        });

        return res.status(200).json({ token: token });
    } catch (error) {
        res.status(500).json({ error: 'Login failed' });
    }
});

// Protected route
app.get('/', verifyToken, async (req, res) =&gt; {
    let userID = parseInt(req.userId);
    const new_user = await prisma.user.findUnique({ where: { id: userID } });

    res.status(200).json({ me: new_user });
});

// App Listening
app.listen(PORT, () =&gt; {
    console.log('Listening ....');
});
</code></pre>
<h3 id="frontend"><a class="header" href="#frontend">Frontend</a></h3>
<pre><code class="language-sh">mkdir jwt-frontend
cd jwt-frontend
npm init -y
</code></pre>
<blockquote>
<p>Code</p>
</blockquote>
<pre><code class="language-js">import React, { useEffect } from 'react';

const App = () =&gt; {
    useEffect(() =&gt; {
        const fetchData = async () =&gt; {
            const data = await fetch('http://localhost:3333/login', {
                method: 'POST',
                credentials: 'include',
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'sad@sad.com',
                    password: 'helloworld'
                })
            });

            const resp = await data.json();
            console.log(resp);
        };

        fetchData();
    }, []);
    return &lt;div&gt;App&lt;/div&gt;;
};

export default App;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="golang-basics"><a class="header" href="#golang-basics">Golang Basics</a></h1>
<h3 id="simple-hello-world"><a class="header" href="#simple-hello-world">Simple hello world</a></h3>
<blockquote>
<p>Strings must be enclosed within double quotes
Characters must be enclosed within single quotes</p>
</blockquote>
<pre><code class="language-go">package main
import "fmt"

func main() {
    // New Line printing
    fmt.Println("Hello!")

    // Print in the same line
    fmt.Print("Hello!")
}
</code></pre>
<h3 id="building-and-running"><a class="header" href="#building-and-running">Building and Running</a></h3>
<blockquote>
<p>Build</p>
</blockquote>
<pre><code class="language-sh">go build &lt;name_of_file&gt;
</code></pre>
<blockquote>
<p>Run</p>
</blockquote>
<pre><code class="language-sh">go build &lt;name_of_file&gt;
</code></pre>
<h3 id="variables-and-data-types"><a class="header" href="#variables-and-data-types">Variables and Data-types</a></h3>
<blockquote>
<p>Number</p>
</blockquote>
<blockquote>
<p>Unsigned Integers (no negatives)</p>
</blockquote>
<ul>
<li>uint8 / byte (0 - 255)</li>
<li>uint16 (0 - 65535)</li>
<li>uint32 (0 to 4294967295)</li>
<li>uint64 (0 to 18446744073709551615)</li>
</ul>
<blockquote>
<p>Signed Integers</p>
</blockquote>
<ul>
<li>int8 (-128 to 127)</li>
<li>int16 (-32768 to 32767)</li>
<li>int32 / rune (-2147483648 to 2147483647)</li>
<li>int64 (-9223372036854775808 to 9223372036854775807)</li>
</ul>
<blockquote>
<p>3 Machine Dependent Types</p>
</blockquote>
<ul>
<li>uint 32 or 64 bits)</li>
<li>int (same size as uint)</li>
<li>uintptr (an unsigned integer to store the uninterpreted bits of a pointer value)</li>
</ul>
<blockquote>
<p>Floating Point Numbers</p>
</blockquote>
<ul>
<li>float32 (IEEE-754 32-bit floating-point numbers)</li>
<li>float64 (IEEE-754 64-bit floating-point numbers)</li>
</ul>
<blockquote>
<p>Complex (Imaginary Parts)</p>
</blockquote>
<ul>
<li>complex64 (Complex numbers with float32 real and imaginary part)</li>
<li>complex128 (Complex numbers with float64 real and imaginary part)</li>
</ul>
<pre><code class="language-go">package main

import "fmt"

func main() {

	// Can change later
	// var name string
	// name = "Bill"
	// name = "asd"

	var a bool = true    // Boolean
	var b uint = 5       // Integer
	var c float32 = 3.14 // Floating point number
	var d string = "Hi!" // String
	b += 10

	fmt.Println("Boolean: ", a)
	fmt.Println("Integer: ", b)
	fmt.Println("Float:   ", c)
	fmt.Println("String:  ", d)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="install-dependencies-4"><a class="header" href="#install-dependencies-4">Install Dependencies</a></h3>
<pre><code class="language-sh">pip install fastapi uvicorn gunicorn pyjwt
</code></pre>
<blockquote>
<p>main.py</p>
</blockquote>
<pre><code class="language-py">from fastapi import Depends, FastAPI, Response, status
import datetime

from fastapi.encoders import jsonable_encoder
from fastapi.responses import JSONResponse
from middlewares.authenticate import authenticate
from helper.utils import jwt_encode
from fastapi.middleware.cors import CORSMiddleware


# Main app
app = FastAPI()

origins = ["http://localhost:5173"]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# Generate JWT Token
@app.get("/login", status_code=200)
async def login(res: Response):
    user = {"id": 1, "name": "John"}
    accToken = await jwt_encode(
        user, int(datetime.datetime.timestamp(datetime.datetime.now())) + (60 * 60)
    )
    refToken = await jwt_encode(
        user,
        int(datetime.datetime.timestamp(datetime.datetime.now())) + (24 * 60 * 60),
    )

    res.set_cookie("refreshToken", refToken, httponly=True, samesite="strict")
    res.headers["Authorization"] = accToken

    return {"accToken": accToken, "id": 1, "user": "John"}


@app.get("/me")
async def me(data: dict = Depends(authenticate)):
    return data
</code></pre>
<blockquote>
<p>helper/utils.py</p>
</blockquote>
<pre><code class="language-py">
import jwt


async def jwt_encode(data, exp):
    return jwt.encode(
        {**data, "exp": exp},
        "secret",
        algorithm="HS256",
    ).decode("utf-8")


async def jwt_decode(encoded_jwt):
    return jwt.decode(encoded_jwt, "secret", algorithms=["HS256"])
</code></pre>
<blockquote>
<p>middlewares/authenticate.py</p>
</blockquote>
<pre><code class="language-py">import sys

sys.path.append("..")


from fastapi.responses import JSONResponse
from fastapi.encoders import jsonable_encoder
from fastapi import Request, Response, status
import datetime
from helper import utils


async def authenticate(req: Request, res: Response):
    accToken, refToken = req.headers.get("Authorization", None), req.cookies.get(
        "refreshToken", None
    )

    # Check if both tokens provided
    if not accToken and not refToken:
        return JSONResponse(
            content=jsonable_encoder({"type": "err", "msg": "No Tokens provided"}),
            status_code=status.HTTP_401_UNAUTHORIZED,
        )

    decoded = {}

    # If acc_token not expired
    try:
        # Decode the jwt token
        decoded = await utils.jwt_decode(accToken)
        req.state.data = decoded.get("name")
        return JSONResponse(
            content=jsonable_encoder(
                {"type": "data", "msg": "Got user back!", "data": decoded.get("name")}
            ),
            status_code=status.HTTP_200_OK,
        )

    # If acc_token expired then use refToken to Generate new accToken
    except Exception as e:
        # Check Refresh token provided
        if not refToken:
            return JSONResponse(
                content=jsonable_encoder(
                    {"type": "err", "msg": "No Refresh Token provided"}
                ),
                status_code=status.HTTP_401_UNAUTHORIZED,
            )

        # If ref_token not expired
        decoded = {}
        try:
            decoded = await utils.jwt_decode(refToken)
            accToken = await utils.jwt_encode(
                {"id": decoded.get("id"), "name": decoded.get("name")},
                int(datetime.datetime.timestamp(datetime.datetime.now())) + 15,
            )
            res.set_cookie("refreshToken", refToken, httponly=True, samesite="strict")
            res.headers["Authorization"] = accToken
            return JSONResponse(
                content=jsonable_encoder(
                    {
                        "type": "data",
                        "msg": "Refreshed Token",
                        "data": {
                            "accToken": accToken,
                            "id": decoded.get("id"),
                            "name": decoded.get("name"),
                        },
                    }
                ),
                status_code=status.HTTP_200_OK,
            )
        # If ref_token expired
        except Exception as e:
            return JSONResponse(
                content=jsonable_encoder(
                    {"type": "err", "msg": "refreshToken expired"}
                ),
                status_code=status.HTTP_401_UNAUTHORIZED,
            )
</code></pre>
<blockquote>
<p>gunicorn.conf.py</p>
</blockquote>
<pre><code class="language-py">
import os
import signal


def worker_int(worker):
    os.kill(worker.pid, signal.SIGINT)
</code></pre>
<blockquote>
<p>run.sh</p>
</blockquote>
<pre><code class="language-sh">#!/usr/bin/env bash

WORKERS=6
PORT=5000

gunicorn main:app -w "${WORKERS}" -b 0.0.0.0:"${PORT}" -k uvicorn.workers.UvicornWorker --log-file=- --log-level DEBUG --reload
</code></pre>
<blockquote>
<p>App.tsx</p>
</blockquote>
<pre><code class="language-ts">import { useCallback } from 'react';

const App = () =&gt; {
    const handleLogin = useCallback(async () =&gt; {
        const url = 'http://localhost:5000/login';
        const data = await fetch(url, {
            credentials: 'include',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json'
            }
        });
        const final = await data.json();
        console.log('DATA', final);

        if (final['accToken']) {
            localStorage.setItem('accToken', final['accToken']);
        } else {
            console.log('No data found');
        }
    }, []);

    const me = useCallback(async () =&gt; {
        const url = 'http://localhost:5000/me';
        const data = await fetch(url, {
            credentials: 'include',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
                Authorization: localStorage.getItem('accToken')
            }
        });
        const final = await data.json();
        if (final['accToken']) {
            localStorage.setItem('accToken', final['accToken']);
            console.log('DATA', final);
        } else {
            console.log(final);
        }
    }, []);

    return (
        &lt;div&gt;
            &lt;button
                type="button"
                onClick={() =&gt; {
                    handleLogin();
                }}
            &gt;
                Login
            &lt;/button&gt;
            &lt;button
                type="button"
                onClick={() =&gt; {
                    me();
                }}
            &gt;
                Me
            &lt;/button&gt;
        &lt;/div&gt;
    );
};

export default App;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
